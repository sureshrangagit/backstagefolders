"use strict";
'use client';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SelectItem = void 0;
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _SelectRootContext = require("../root/SelectRootContext");
var _SelectIndexContext = require("../root/SelectIndexContext");
var _useCompositeListItem = require("../../composite/list/useCompositeListItem");
var _useForkRef = require("../../utils/useForkRef");
var _useComponentRenderer = require("../../utils/useComponentRenderer");
var _useSelectItem = require("./useSelectItem");
var _useEnhancedEffect = require("../../utils/useEnhancedEffect");
var _useLatestRef = require("../../utils/useLatestRef");
var _SelectItemContext = require("./SelectItemContext");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const InnerSelectItem = /*#__PURE__*/React.forwardRef(function InnerSelectItem(props, forwardedRef) {
  const {
    className,
    disabled = false,
    highlighted,
    selected,
    getRootItemProps,
    render,
    setOpen,
    typingRef,
    selectionRef,
    open,
    value,
    setValue,
    selectedIndexRef,
    indexRef,
    setActiveIndex,
    popupRef,
    keyboardActiveRef,
    ...otherProps
  } = props;
  const state = React.useMemo(() => ({
    disabled,
    open,
    highlighted,
    selected
  }), [disabled, open, highlighted, selected]);
  const {
    getItemProps,
    rootRef
  } = (0, _useSelectItem.useSelectItem)({
    open,
    setOpen,
    disabled,
    highlighted,
    selected,
    ref: forwardedRef,
    typingRef,
    handleSelect: () => setValue(value),
    selectionRef,
    selectedIndexRef,
    indexRef,
    setActiveIndex,
    popupRef,
    keyboardActiveRef
  });
  const mergedRef = (0, _useForkRef.useForkRef)(rootRef, forwardedRef);
  const {
    renderElement
  } = (0, _useComponentRenderer.useComponentRenderer)({
    propGetter(externalProps = {}) {
      const rootProps = getRootItemProps({
        ...externalProps,
        active: highlighted,
        selected
      });
      // With our custom `focusItemOnHover` implementation, this interferes with the logic and can
      // cause the index state to be stuck when leaving the select popup.
      delete rootProps.onFocus;
      return getItemProps(rootProps);
    },
    render: render ?? 'div',
    ref: mergedRef,
    className,
    state,
    extraProps: otherProps
  });
  const contextValue = React.useMemo(() => ({
    selected,
    indexRef
  }), [selected, indexRef]);
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(_SelectItemContext.SelectItemContext.Provider, {
    value: contextValue,
    children: renderElement()
  });
});
process.env.NODE_ENV !== "production" ? InnerSelectItem.propTypes /* remove-proptypes */ = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  children: _propTypes.default.node,
  /**
   * CSS class applied to the element, or a function that
   * returns a class based on the component’s state.
   */
  className: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.string]),
  /**
   * Whether the component should ignore user interaction.
   * @default false
   */
  disabled: _propTypes.default.bool,
  /**
   * @ignore
   */
  getRootItemProps: _propTypes.default.func.isRequired,
  /**
   * @ignore
   */
  highlighted: _propTypes.default.bool.isRequired,
  /**
   * @ignore
   */
  indexRef: _propTypes.default.shape({
    current: _propTypes.default.number.isRequired
  }).isRequired,
  /**
   * @ignore
   */
  keyboardActiveRef: _propTypes.default.shape({
    current: _propTypes.default.bool.isRequired
  }).isRequired,
  /**
   * Overrides the text label to use on the trigger when this item is selected
   * and when the item is matched during keyboard text navigation.
   */
  label: _propTypes.default.string,
  /**
   * @ignore
   */
  open: _propTypes.default.bool.isRequired,
  /**
   * @ignore
   */
  popupRef: _propTypes.default.shape({
    current: _propTypes.default.object
  }).isRequired,
  /**
   * Allows you to replace the component’s HTML element
   * with a different tag, or compose it with another component.
   *
   * Accepts a `ReactElement` or a function that returns the element to render.
   */
  render: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.func]),
  /**
   * @ignore
   */
  selected: _propTypes.default.bool.isRequired,
  /**
   * @ignore
   */
  selectedIndexRef: _propTypes.default.shape({
    current: _propTypes.default.number
  }).isRequired,
  /**
   * @ignore
   */
  selectionRef: _propTypes.default.shape({
    current: _propTypes.default.shape({
      allowSelect: _propTypes.default.bool.isRequired,
      allowSelectedMouseUp: _propTypes.default.bool.isRequired,
      allowUnselectedMouseUp: _propTypes.default.bool.isRequired
    }).isRequired
  }).isRequired,
  /**
   * @ignore
   */
  setActiveIndex: _propTypes.default.func.isRequired,
  /**
   * @ignore
   */
  setOpen: _propTypes.default.func.isRequired,
  /**
   * @ignore
   */
  setValue: _propTypes.default.func.isRequired,
  /**
   * @ignore
   */
  typingRef: _propTypes.default.shape({
    current: _propTypes.default.bool.isRequired
  }).isRequired,
  /**
   * @ignore
   */
  value: _propTypes.default.any.isRequired
} : void 0;
const MemoizedInnerSelectItem = /*#__PURE__*/React.memo(InnerSelectItem);

/**
 * An individual option in the select menu.
 * Renders a `<div>` element.
 *
 * Documentation: [Base UI Select](https://base-ui.com/react/components/select)
 */
const SelectItem = exports.SelectItem = /*#__PURE__*/React.forwardRef(function SelectItem(props, forwardedRef) {
  const {
    value: valueProp = null,
    label,
    ...otherProps
  } = props;
  const listItem = (0, _useCompositeListItem.useCompositeListItem)({
    label
  });
  const {
    activeIndex,
    selectedIndex,
    setActiveIndex
  } = (0, _SelectIndexContext.useSelectIndexContext)();
  const {
    getItemProps,
    setOpen,
    setValue,
    open,
    selectionRef,
    typingRef,
    valuesRef,
    popupRef,
    registerSelectedItem,
    value,
    keyboardActiveRef
  } = (0, _SelectRootContext.useSelectRootContext)();
  const itemRef = React.useRef(null);
  const selectedIndexRef = (0, _useLatestRef.useLatestRef)(selectedIndex);
  const indexRef = (0, _useLatestRef.useLatestRef)(listItem.index);
  const mergedRef = (0, _useForkRef.useForkRef)(listItem.ref, forwardedRef, itemRef);
  const hasRegistered = listItem.index !== -1;
  (0, _useEnhancedEffect.useEnhancedEffect)(() => {
    if (!hasRegistered) {
      return undefined;
    }
    const values = valuesRef.current;
    values[listItem.index] = valueProp;
    return () => {
      delete values[listItem.index];
    };
  }, [hasRegistered, listItem.index, valueProp, valuesRef]);
  (0, _useEnhancedEffect.useEnhancedEffect)(() => {
    if (hasRegistered && valueProp === value) {
      registerSelectedItem(listItem.index);
    }
  }, [hasRegistered, listItem.index, registerSelectedItem, valueProp, value]);
  const highlighted = activeIndex === listItem.index;
  const selected = selectedIndex === listItem.index;
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(MemoizedInnerSelectItem, {
    ref: mergedRef,
    highlighted: highlighted,
    selected: selected,
    getRootItemProps: getItemProps,
    setOpen: setOpen,
    open: open,
    selectionRef: selectionRef,
    typingRef: typingRef,
    value: valueProp,
    setValue: setValue,
    selectedIndexRef: selectedIndexRef,
    indexRef: indexRef,
    setActiveIndex: setActiveIndex,
    popupRef: popupRef,
    keyboardActiveRef: keyboardActiveRef,
    ...otherProps
  });
});
process.env.NODE_ENV !== "production" ? SelectItem.propTypes /* remove-proptypes */ = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  children: _propTypes.default.node,
  /**
   * CSS class applied to the element, or a function that
   * returns a class based on the component’s state.
   */
  className: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.string]),
  /**
   * Whether the component should ignore user interaction.
   * @default false
   */
  disabled: _propTypes.default.bool,
  /**
   * Overrides the text label to use on the trigger when this item is selected
   * and when the item is matched during keyboard text navigation.
   */
  label: _propTypes.default.string,
  /**
   * Allows you to replace the component’s HTML element
   * with a different tag, or compose it with another component.
   *
   * Accepts a `ReactElement` or a function that returns the element to render.
   */
  render: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.func]),
  /**
   * A unique value that identifies this select item.
   * @default null
   */
  value: _propTypes.default.any
} : void 0;