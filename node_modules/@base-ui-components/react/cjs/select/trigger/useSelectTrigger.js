"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSelectTrigger = useSelectTrigger;
var React = _interopRequireWildcard(require("react"));
var _utils = require("@floating-ui/react/utils");
var _useButton = require("../../use-button/useButton");
var _mergeProps = require("../../merge-props");
var _useForkRef = require("../../utils/useForkRef");
var _SelectRootContext = require("../root/SelectRootContext");
var _owner = require("../../utils/owner");
var _FieldRootContext = require("../../field/root/FieldRootContext");
var _getPseudoElementBounds = require("../../utils/getPseudoElementBounds");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function useSelectTrigger(parameters) {
  const BOUNDARY_OFFSET = 2;
  const {
    disabled = false,
    rootRef: externalRef
  } = parameters;
  const {
    open,
    setOpen,
    setTriggerElement,
    selectionRef,
    value,
    fieldControlValidation,
    setTouchModality,
    positionerElement,
    alignItemToTrigger,
    readOnly
  } = (0, _SelectRootContext.useSelectRootContext)();
  const {
    labelId,
    setTouched,
    setFocused,
    validationMode
  } = (0, _FieldRootContext.useFieldRootContext)();
  const triggerRef = React.useRef(null);
  const timeoutRef = React.useRef(-1);
  const mergedRef = (0, _useForkRef.useForkRef)(externalRef, triggerRef);
  const {
    getButtonProps,
    buttonRef
  } = (0, _useButton.useButton)({
    disabled,
    buttonRef: mergedRef
  });
  const handleRef = (0, _useForkRef.useForkRef)(buttonRef, setTriggerElement);
  React.useEffect(() => {
    if (open) {
      // mousedown -> mouseup on selected item should not select within 400ms.
      const timeoutId1 = window.setTimeout(() => {
        selectionRef.current.allowSelectedMouseUp = true;
      }, 400);
      // mousedown -> move to unselected item -> mouseup should not select within 200ms.
      const timeoutId2 = window.setTimeout(() => {
        selectionRef.current.allowUnselectedMouseUp = true;
      }, 200);
      return () => {
        clearTimeout(timeoutId1);
        clearTimeout(timeoutId2);
      };
    }
    selectionRef.current = {
      allowSelectedMouseUp: false,
      allowUnselectedMouseUp: false,
      allowSelect: true
    };
    clearTimeout(timeoutRef.current);
    return undefined;
  }, [open, selectionRef]);
  const getTriggerProps = React.useCallback(externalProps => {
    return (0, _mergeProps.mergeProps)({
      'aria-labelledby': labelId,
      'aria-readonly': readOnly || undefined,
      tabIndex: disabled ? -1 : 0,
      // this is needed to make the button focused after click in Safari
      ref: handleRef,
      onFocus() {
        setFocused(true);
        // The popup element shouldn't obscure the focused trigger.
        if (open && alignItemToTrigger) {
          setOpen(false);
        }
      },
      onBlur() {
        setTouched(true);
        setFocused(false);
        if (validationMode === 'onBlur') {
          fieldControlValidation.commitValidation(value);
        }
      },
      onPointerMove({
        pointerType
      }) {
        setTouchModality(pointerType === 'touch');
      },
      onPointerDown({
        pointerType
      }) {
        setTouchModality(pointerType === 'touch');
      },
      onMouseDown(event) {
        if (open) {
          return;
        }
        const doc = (0, _owner.ownerDocument)(event.currentTarget);
        function handleMouseUp(mouseEvent) {
          if (!triggerRef.current) {
            return;
          }
          const mouseUpTarget = mouseEvent.target;

          // Early return if clicked on trigger element or its children
          if ((0, _utils.contains)(triggerRef.current, mouseUpTarget) || (0, _utils.contains)(positionerElement, mouseUpTarget) || mouseUpTarget === triggerRef.current) {
            return;
          }
          const bounds = (0, _getPseudoElementBounds.getPseudoElementBounds)(triggerRef.current);
          if (mouseEvent.clientX >= bounds.left - BOUNDARY_OFFSET && mouseEvent.clientX <= bounds.right + BOUNDARY_OFFSET && mouseEvent.clientY >= bounds.top - BOUNDARY_OFFSET && mouseEvent.clientY <= bounds.bottom + BOUNDARY_OFFSET) {
            return;
          }
          setOpen(false, mouseEvent);
        }

        // Firefox can fire this upon mousedown
        timeoutRef.current = window.setTimeout(() => {
          doc.addEventListener('mouseup', handleMouseUp, {
            once: true
          });
        });
      }
    }, fieldControlValidation.getValidationProps(externalProps), getButtonProps,
    // ensure nested useButton does not overwrite the combobox role:
    // <Toolbar.Button render={<Select.Trigger />} />
    {
      role: 'combobox'
    });
  }, [getButtonProps, fieldControlValidation, labelId, readOnly, disabled, handleRef, setFocused, open, alignItemToTrigger, setOpen, setTouched, setTouchModality, validationMode, value, positionerElement]);
  return React.useMemo(() => ({
    getTriggerProps,
    rootRef: handleRef
  }), [getTriggerProps, handleRef]);
}