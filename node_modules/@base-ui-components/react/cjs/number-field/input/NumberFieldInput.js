"use strict";
'use client';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NumberFieldInput = void 0;
var React = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _NumberFieldRootContext = require("../root/NumberFieldRootContext");
var _useComponentRenderer = require("../../utils/useComponentRenderer");
var _useForkRef = require("../../utils/useForkRef");
var _FieldRootContext = require("../../field/root/FieldRootContext");
var _useFieldControlValidation = require("../../field/control/useFieldControlValidation");
var _constants = require("../../field/utils/constants");
var _mergeProps = require("../../merge-props");
var _constants2 = require("../utils/constants");
var _parse = require("../utils/parse");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * The native input control in the number field.
 * Renders an `<input>` element.
 *
 * Documentation: [Base UI Number Field](https://base-ui.com/react/components/number-field)
 */
const NumberFieldInput = exports.NumberFieldInput = /*#__PURE__*/React.forwardRef(function NumberFieldInput(props, forwardedRef) {
  const {
    render,
    className,
    ...otherProps
  } = props;
  const {
    allowInputSyncRef,
    autoFocus,
    disabled,
    formatOptionsRef,
    getAllowedNonNumericKeys,
    getStepAmount,
    id,
    incrementValue,
    inputMode,
    inputValue,
    invalid,
    max,
    mergedRef,
    min,
    name,
    readOnly,
    required,
    setValue,
    state,
    valueRef,
    setInputValue,
    locale
  } = (0, _NumberFieldRootContext.useNumberFieldRootContext)();
  const {
    labelId,
    validationMode,
    setTouched,
    setFocused
  } = (0, _FieldRootContext.useFieldRootContext)();
  const {
    getInputValidationProps,
    getValidationProps,
    commitValidation,
    inputRef: inputValidationRef
  } = (0, _useFieldControlValidation.useFieldControlValidation)();
  const hasTouchedInputRef = React.useRef(false);
  const handleInputRef = (0, _useForkRef.useForkRef)(forwardedRef, inputValidationRef, mergedRef);
  const getInputProps = React.useCallback((externalProps = {}) => (0, _mergeProps.mergeProps)({
    id,
    required,
    autoFocus,
    name,
    disabled,
    readOnly,
    inputMode,
    value: inputValue,
    ref: handleInputRef,
    type: 'text',
    autoComplete: 'off',
    autoCorrect: 'off',
    spellCheck: 'false',
    'aria-roledescription': 'Number field',
    'aria-invalid': invalid || undefined,
    'aria-labelledby': labelId,
    // If the server's locale does not match the client's locale, the formatting may not match,
    // causing a hydration mismatch.
    suppressHydrationWarning: true,
    onFocus(event) {
      if (event.defaultPrevented || readOnly || disabled || hasTouchedInputRef.current) {
        return;
      }
      hasTouchedInputRef.current = true;
      setFocused(true);

      // Browsers set selection at the start of the input field by default. We want to set it at
      // the end for the first focus.
      const target = event.currentTarget;
      const length = target.value.length;
      target.setSelectionRange(length, length);
    },
    onBlur(event) {
      if (event.defaultPrevented || readOnly || disabled) {
        return;
      }
      setTouched(true);
      setFocused(false);
      if (validationMode === 'onBlur') {
        commitValidation(valueRef.current);
      }
      allowInputSyncRef.current = true;
      if (inputValue.trim() === '') {
        setValue(null);
        return;
      }
      const parsedValue = (0, _parse.parseNumber)(inputValue, locale, formatOptionsRef.current);
      if (parsedValue !== null) {
        setValue(parsedValue, event.nativeEvent);
      }
    },
    onChange(event) {
      // Workaround for https://github.com/facebook/react/issues/9023
      if (event.nativeEvent.defaultPrevented) {
        return;
      }
      allowInputSyncRef.current = false;
      const targetValue = event.target.value;
      if (targetValue.trim() === '') {
        setInputValue(targetValue);
        setValue(null, event.nativeEvent);
        return;
      }
      if (event.isTrusted) {
        setInputValue(targetValue);
        return;
      }
      const parsedValue = (0, _parse.parseNumber)(targetValue, locale, formatOptionsRef.current);
      if (parsedValue !== null) {
        setInputValue(targetValue);
        setValue(parsedValue, event.nativeEvent);
      }
    },
    onKeyDown(event) {
      if (event.defaultPrevented || readOnly || disabled) {
        return;
      }
      const nativeEvent = event.nativeEvent;
      allowInputSyncRef.current = true;
      const allowedNonNumericKeys = getAllowedNonNumericKeys();
      let isAllowedNonNumericKey = allowedNonNumericKeys.includes(event.key);
      const {
        decimal,
        currency,
        percentSign
      } = (0, _parse.getNumberLocaleDetails)([], formatOptionsRef.current);
      const selectionStart = event.currentTarget.selectionStart;
      const selectionEnd = event.currentTarget.selectionEnd;
      const isAllSelected = selectionStart === 0 && selectionEnd === inputValue.length;

      // Allow the minus key only if there isn't already a plus or minus sign, or if all the text
      // is selected, or if only the minus sign is highlighted.
      if (event.key === '-' && allowedNonNumericKeys.includes('-')) {
        const isMinusHighlighted = selectionStart === 0 && selectionEnd === 1 && inputValue[0] === '-';
        isAllowedNonNumericKey = !inputValue.includes('-') || isAllSelected || isMinusHighlighted;
      }

      // Only allow one of each symbol.
      [decimal, currency, percentSign].forEach(symbol => {
        if (event.key === symbol) {
          const symbolIndex = inputValue.indexOf(symbol);
          const isSymbolHighlighted = selectionStart === symbolIndex && selectionEnd === symbolIndex + 1;
          isAllowedNonNumericKey = !inputValue.includes(symbol) || isAllSelected || isSymbolHighlighted;
        }
      });
      const isLatinNumeral = /^[0-9]$/.test(event.key);
      const isArabicNumeral = _parse.ARABIC_RE.test(event.key);
      const isHanNumeral = _parse.HAN_RE.test(event.key);
      const isNavigateKey = ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter'].includes(event.key);
      if (
      // Allow composition events (e.g., pinyin)
      // event.nativeEvent.isComposing does not work in Safari:
      // https://bugs.webkit.org/show_bug.cgi?id=165004
      event.which === 229 || event.altKey || event.ctrlKey || event.metaKey || isAllowedNonNumericKey || isLatinNumeral || isArabicNumeral || isHanNumeral || isNavigateKey) {
        return;
      }

      // We need to commit the number at this point if the input hasn't been blurred.
      const parsedValue = (0, _parse.parseNumber)(inputValue, locale, formatOptionsRef.current);
      const amount = getStepAmount(event) ?? _constants2.DEFAULT_STEP;

      // Prevent insertion of text or caret from moving.
      event.preventDefault();
      if (event.key === 'ArrowUp') {
        incrementValue(amount, 1, parsedValue, nativeEvent);
      } else if (event.key === 'ArrowDown') {
        incrementValue(amount, -1, parsedValue, nativeEvent);
      } else if (event.key === 'Home' && min != null) {
        setValue(min, nativeEvent);
      } else if (event.key === 'End' && max != null) {
        setValue(max, nativeEvent);
      }
    },
    onPaste(event) {
      if (event.defaultPrevented || readOnly || disabled) {
        return;
      }

      // Prevent `onChange` from being called.
      event.preventDefault();
      const clipboardData = event.clipboardData || window.Clipboard;
      const pastedData = clipboardData.getData('text/plain');
      const parsedValue = (0, _parse.parseNumber)(pastedData, locale, formatOptionsRef.current);
      if (parsedValue !== null) {
        allowInputSyncRef.current = false;
        setValue(parsedValue, event.nativeEvent);
        setInputValue(pastedData);
      }
    }
  }, getInputValidationProps(getValidationProps(externalProps))), [getInputValidationProps, getValidationProps, id, required, autoFocus, name, disabled, readOnly, inputMode, inputValue, invalid, labelId, setFocused, setTouched, validationMode, formatOptionsRef, commitValidation, valueRef, setValue, getAllowedNonNumericKeys, getStepAmount, min, max, incrementValue, setInputValue, allowInputSyncRef, locale, handleInputRef]);
  const mergedInputRef = (0, _useForkRef.useForkRef)(forwardedRef, mergedRef);
  const {
    renderElement
  } = (0, _useComponentRenderer.useComponentRenderer)({
    propGetter: getInputProps,
    ref: mergedInputRef,
    render: render ?? 'input',
    className,
    state,
    extraProps: otherProps,
    customStyleHookMapping: _constants.fieldValidityMapping
  });
  return renderElement();
});
process.env.NODE_ENV !== "production" ? NumberFieldInput.propTypes /* remove-proptypes */ = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  children: _propTypes.default.node,
  /**
   * CSS class applied to the element, or a function that
   * returns a class based on the component’s state.
   */
  className: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.string]),
  /**
   * Allows you to replace the component’s HTML element
   * with a different tag, or compose it with another component.
   *
   * Accepts a `ReactElement` or a function that returns the element to render.
   */
  render: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.func])
} : void 0;