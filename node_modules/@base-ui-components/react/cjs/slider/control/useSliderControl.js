"use strict";
'use client';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSliderControl = useSliderControl;
var React = _interopRequireWildcard(require("react"));
var _mergeProps = require("../../merge-props");
var _owner = require("../../utils/owner");
var _useForkRef = require("../../utils/useForkRef");
var _useEventCallback = require("../../utils/useEventCallback");
var _useSliderRoot = require("../root/useSliderRoot");
var _useFieldControlValidation = require("../../field/control/useFieldControlValidation");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function trackFinger(event, touchIdRef) {
  // The event is TouchEvent
  if (touchIdRef.current !== undefined && event.changedTouches) {
    const touchEvent = event;
    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
      const touch = touchEvent.changedTouches[i];
      if (touch.identifier === touchIdRef.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return null;
  }

  // The event is PointerEvent
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function useSliderControl(parameters) {
  const {
    disabled,
    dragging,
    getFingerState,
    lastChangedValueRef,
    minStepsBetweenValues,
    commitValue,
    percentageValues,
    registerSliderControl,
    rootRef: externalRef,
    setActive,
    setDragging,
    setValue,
    step,
    thumbRefs
  } = parameters;
  const {
    commitValidation
  } = (0, _useFieldControlValidation.useFieldControlValidation)();
  const controlRef = React.useRef(null);
  const handleRootRef = (0, _useForkRef.useForkRef)(externalRef, registerSliderControl, controlRef);

  // A number that uniquely identifies the current finger in the touch session.
  const touchIdRef = React.useRef(null);
  const moveCountRef = React.useRef(0);
  /**
   * The difference between the value at the finger origin and the value at
   * the center of the thumb scaled down to fit the range [0, 1]
   */
  const offsetRef = React.useRef(0);
  const handleTouchMove = (0, _useEventCallback.useEventCallback)(nativeEvent => {
    const fingerPosition = trackFinger(nativeEvent, touchIdRef);
    if (fingerPosition == null) {
      return;
    }
    moveCountRef.current += 1;

    // Cancel move in case some other element consumed a pointerup event and it was not fired.
    // @ts-ignore buttons doesn't not exists on touch event
    if (nativeEvent.type === 'pointermove' && nativeEvent.buttons === 0) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      handleTouchEnd(nativeEvent);
      return;
    }
    const finger = getFingerState(fingerPosition, false, offsetRef.current);
    if (finger == null) {
      return;
    }
    (0, _useSliderRoot.focusThumb)(finger.thumbIndex, controlRef, setActive);
    if ((0, _useSliderRoot.validateMinimumDistance)(finger.value, step, minStepsBetweenValues)) {
      if (!dragging && moveCountRef.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
        setDragging(true);
      }
      setValue(finger.value, finger.percentageValues, finger.thumbIndex, nativeEvent);
    }
  });
  const handleTouchEnd = (0, _useEventCallback.useEventCallback)(nativeEvent => {
    const fingerPosition = trackFinger(nativeEvent, touchIdRef);
    setDragging(false);
    if (fingerPosition == null) {
      return;
    }
    const finger = getFingerState(fingerPosition, false);
    if (finger == null) {
      return;
    }
    setActive(-1);
    commitValidation(lastChangedValueRef.current ?? finger.value);
    commitValue(lastChangedValueRef.current ?? finger.value, nativeEvent);
    touchIdRef.current = null;
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    stopListening();
  });
  const handleTouchStart = (0, _useEventCallback.useEventCallback)(nativeEvent => {
    if (disabled) {
      return;
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      touchIdRef.current = touch.identifier;
    }
    const fingerPosition = trackFinger(nativeEvent, touchIdRef);
    if (fingerPosition != null) {
      const finger = getFingerState(fingerPosition, true);
      if (finger == null) {
        return;
      }
      (0, _useSliderRoot.focusThumb)(finger.thumbIndex, controlRef, setActive);
      setValue(finger.value, finger.percentageValues, finger.thumbIndex, nativeEvent);
    }
    moveCountRef.current = 0;
    const doc = (0, _owner.ownerDocument)(controlRef.current);
    doc.addEventListener('touchmove', handleTouchMove, {
      passive: true
    });
    doc.addEventListener('touchend', handleTouchEnd, {
      passive: true
    });
  });
  const stopListening = (0, _useEventCallback.useEventCallback)(() => {
    offsetRef.current = 0;
    const doc = (0, _owner.ownerDocument)(controlRef.current);
    doc.removeEventListener('pointermove', handleTouchMove);
    doc.removeEventListener('pointerup', handleTouchEnd);
    doc.removeEventListener('touchmove', handleTouchMove);
    doc.removeEventListener('touchend', handleTouchEnd);
  });
  React.useEffect(() => {
    const {
      current: sliderControl
    } = controlRef;
    if (!sliderControl) {
      return () => stopListening();
    }
    sliderControl.addEventListener('touchstart', handleTouchStart, {
      passive: true
    });
    return () => {
      sliderControl.removeEventListener('touchstart', handleTouchStart);
      stopListening();
    };
  }, [stopListening, handleTouchStart, controlRef]);
  React.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const getRootProps = React.useCallback((externalProps = {}) => {
    return (0, _mergeProps.mergeProps)({
      onPointerDown(event) {
        if (disabled) {
          return;
        }
        if (event.defaultPrevented) {
          return;
        }

        // Only handle left clicks
        if (event.button !== 0) {
          return;
        }

        // Avoid text selection
        event.preventDefault();
        const fingerPosition = trackFinger(event, touchIdRef);
        if (fingerPosition != null) {
          const finger = getFingerState(fingerPosition, true);
          if (finger == null) {
            return;
          }
          (0, _useSliderRoot.focusThumb)(finger.thumbIndex, controlRef, setActive);

          // if the event lands on a thumb, don't change the value, just get the
          // percentageValue difference represented by the distance between the click origin
          // and the coordinates of the value on the track area
          if (thumbRefs.current.includes(event.target)) {
            offsetRef.current = percentageValues[finger.thumbIndex] / 100 - finger.valueRescaled;
          } else {
            setValue(finger.value, finger.percentageValues, finger.thumbIndex, event.nativeEvent);
          }
        }
        moveCountRef.current = 0;
        const doc = (0, _owner.ownerDocument)(controlRef.current);
        doc.addEventListener('pointermove', handleTouchMove, {
          passive: true
        });
        doc.addEventListener('pointerup', handleTouchEnd);
      },
      ref: handleRootRef
    }, externalProps);
  }, [disabled, getFingerState, handleRootRef, handleTouchMove, handleTouchEnd, setValue, percentageValues, setActive, thumbRefs]);
  return React.useMemo(() => ({
    getRootProps
  }), [getRootProps]);
}