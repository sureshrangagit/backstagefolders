"use strict";
'use client';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.focusThumb = focusThumb;
exports.useSliderRoot = useSliderRoot;
exports.validateMinimumDistance = validateMinimumDistance;
var React = _interopRequireWildcard(require("react"));
var _utils = require("@floating-ui/react/utils");
var _areArraysEqual = require("../../utils/areArraysEqual");
var _clamp = require("../../utils/clamp");
var _mergeProps = require("../../merge-props");
var _owner = require("../../utils/owner");
var _useControlled = require("../../utils/useControlled");
var _useEnhancedEffect = require("../../utils/useEnhancedEffect");
var _useForkRef = require("../../utils/useForkRef");
var _valueToPercent = require("../../utils/valueToPercent");
var _warn = require("../../utils/warn");
var _DirectionContext = require("../../direction-provider/DirectionContext");
var _useField = require("../../field/useField");
var _FieldRootContext = require("../../field/root/FieldRootContext");
var _useFieldControlValidation = require("../../field/control/useFieldControlValidation");
var _asc = require("../utils/asc");
var _getSliderValue = require("../utils/getSliderValue");
var _replaceArrayItemAtIndex = require("../utils/replaceArrayItemAtIndex");
var _roundValueToStep = require("../utils/roundValueToStep");
var _useEventCallback = require("../../utils/useEventCallback");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === 'number' && typeof oldValue === 'number') {
    return newValue === oldValue;
  }
  if (Array.isArray(newValue) && Array.isArray(oldValue)) {
    return (0, _areArraysEqual.areArraysEqual)(newValue, oldValue);
  }
  return false;
}
function findClosest(values, currentValue) {
  const {
    index: closestIndex
  } = values.reduce((acc, value, index) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index
      };
    }
    return acc;
  }, null) ?? {};
  return closestIndex;
}
function valueArrayToPercentages(values, min, max) {
  const output = [];
  for (let i = 0; i < values.length; i += 1) {
    output.push((0, _clamp.clamp)((0, _valueToPercent.valueToPercent)(values[i], min, max), 0, 100));
  }
  return output;
}
function focusThumb(thumbIndex, sliderRef, setActive) {
  if (!sliderRef.current) {
    return;
  }
  const doc = (0, _owner.ownerDocument)(sliderRef.current);
  if (!sliderRef.current.contains(doc.activeElement) || Number(doc?.activeElement?.getAttribute('data-index')) !== thumbIndex) {
    sliderRef.current.querySelector(`[type="range"][data-index="${thumbIndex}"]`).focus();
  }
  if (setActive) {
    setActive(thumbIndex);
  }
}
function validateMinimumDistance(values, step, minStepsBetweenValues) {
  if (!Array.isArray(values)) {
    return true;
  }
  const distances = values.reduce((acc, val, index, vals) => {
    if (index === vals.length - 1) {
      return acc;
    }
    acc.push(Math.abs(val - vals[index + 1]));
    return acc;
  }, []);
  return Math.min(...distances) >= step * minStepsBetweenValues;
}

/**
 */
function useSliderRoot(parameters) {
  const {
    'aria-labelledby': ariaLabelledby,
    defaultValue,
    disabled = false,
    id,
    largeStep = 10,
    max = 100,
    min = 0,
    minStepsBetweenValues = 0,
    name,
    onValueChange,
    onValueCommitted,
    orientation = 'horizontal',
    rootRef,
    step = 1,
    value: valueProp
  } = parameters;
  const direction = (0, _DirectionContext.useDirection)();
  const {
    setControlId,
    setTouched,
    setDirty,
    validityData,
    validationMode
  } = (0, _FieldRootContext.useFieldRootContext)();
  const {
    getValidationProps,
    inputRef: inputValidationRef,
    commitValidation
  } = (0, _useFieldControlValidation.useFieldControlValidation)();

  // The internal value is potentially unsorted, e.g. to support frozen arrays
  // https://github.com/mui/material-ui/pull/28472
  const [valueUnwrapped, setValueUnwrapped] = (0, _useControlled.useControlled)({
    controlled: valueProp,
    default: defaultValue ?? min,
    name: 'Slider'
  });
  const sliderRef = React.useRef(null);
  const controlRef = React.useRef(null);
  const thumbRefs = React.useRef([]);
  const lastChangedValueRef = React.useRef(null);
  const [thumbMap, setThumbMap] = React.useState(() => new Map());
  (0, _useEnhancedEffect.useEnhancedEffect)(() => {
    setControlId(id);
    return () => {
      setControlId(undefined);
    };
  }, [id, setControlId]);
  (0, _useField.useField)({
    id,
    commitValidation,
    value: valueUnwrapped,
    controlRef
  });

  // We can't use the :active browser pseudo-classes.
  // - The active state isn't triggered when clicking on the rail.
  // - The active state isn't transferred when inversing a range slider.
  const [active, setActive] = React.useState(-1);
  const [dragging, setDragging] = React.useState(false);
  const registerSliderControl = React.useCallback(element => {
    if (element) {
      controlRef.current = element;
      inputValidationRef.current = element.querySelector('input[type="range"]');
    }
  }, [inputValidationRef]);
  const range = Array.isArray(valueUnwrapped);
  const values = React.useMemo(() => {
    if (!range) {
      return [(0, _clamp.clamp)(valueUnwrapped, min, max)];
    }
    return valueUnwrapped.slice().sort(_asc.asc);
  }, [max, min, range, valueUnwrapped]);
  function initializePercentageValues() {
    return valueArrayToPercentages(values, min, max);
  }
  const [percentageValues, setPercentageValues] = React.useState(initializePercentageValues);
  const setValue = (0, _useEventCallback.useEventCallback)((newValue, newPercentageValues, thumbIndex, event) => {
    if (Number.isNaN(newValue) || areValuesEqual(newValue, valueUnwrapped)) {
      return;
    }
    setValueUnwrapped(newValue);
    setPercentageValues(newPercentageValues);
    // Redefine target to allow name and value to be read.
    // This allows seamless integration with the most popular form libraries.
    // https://github.com/mui/material-ui/issues/13485#issuecomment-676048492
    // Clone the event to not override `target` of the original event.
    // @ts-ignore The nativeEvent is function, not object
    const clonedEvent = new event.constructor(event.type, event);
    Object.defineProperty(clonedEvent, 'target', {
      writable: true,
      value: {
        value: newValue,
        name
      }
    });
    lastChangedValueRef.current = newValue;
    onValueChange(newValue, clonedEvent, thumbIndex);
  });

  // for pointer drag only
  const commitValue = (0, _useEventCallback.useEventCallback)((value, event) => {
    if (Array.isArray(value)) {
      const newPercentageValues = valueArrayToPercentages(value, min, max);
      if (!(0, _areArraysEqual.areArraysEqual)(newPercentageValues, percentageValues)) {
        setPercentageValues(newPercentageValues);
      }
    } else if (typeof value === 'number') {
      setPercentageValues([(0, _valueToPercent.valueToPercent)(value, min, max)]);
    }
    onValueCommitted(value, event);
  });
  const handleRootRef = (0, _useForkRef.useForkRef)(rootRef, sliderRef);

  // for keypresses only
  const handleInputChange = (0, _useEventCallback.useEventCallback)((valueInput, index, event) => {
    const newValue = (0, _getSliderValue.getSliderValue)(valueInput, index, min, max, range, values);
    if (range) {
      focusThumb(index, sliderRef);
    }
    if (validateMinimumDistance(newValue, step, minStepsBetweenValues)) {
      if (Array.isArray(newValue)) {
        setValue(newValue, (0, _replaceArrayItemAtIndex.replaceArrayItemAtIndex)(percentageValues, index, (0, _valueToPercent.valueToPercent)(newValue[index], min, max)), index, event.nativeEvent);
      } else {
        setValue(newValue, [(0, _valueToPercent.valueToPercent)(newValue, min, max)], index, event.nativeEvent);
      }
      setDirty(newValue !== validityData.initialValue);
      setTouched(true);
      onValueCommitted(lastChangedValueRef.current ?? newValue, event.nativeEvent);
      if (validationMode === 'onChange') {
        commitValidation(lastChangedValueRef.current ?? newValue);
      }
    }
  });
  const closestThumbIndexRef = React.useRef(null);
  const getFingerState = (0, _useEventCallback.useEventCallback)((fingerPosition,
  /**
   * When `true`, closestThumbIndexRef is updated.
   * It's `true` when called by touchstart or pointerdown.
   */
  shouldCaptureThumbIndex = false,
  /**
   * The difference between the value at the finger origin and the value at
   * the center of the thumb scaled down to fit the range [0, 1]
   */
  offset = 0) => {
    if (fingerPosition == null) {
      return null;
    }
    const {
      current: sliderControl
    } = controlRef;
    if (!sliderControl) {
      return null;
    }
    const isRtl = direction === 'rtl';
    const isVertical = orientation === 'vertical';
    const {
      width,
      height,
      bottom,
      left
    } = sliderControl.getBoundingClientRect();

    // the value at the finger origin scaled down to fit the range [0, 1]
    let valueRescaled = isVertical ? (bottom - fingerPosition.y) / height + offset : (fingerPosition.x - left) / width + offset * (isRtl ? -1 : 1);
    valueRescaled = (0, _clamp.clamp)(valueRescaled, 0, 1);
    if (isRtl && !isVertical) {
      valueRescaled = 1 - valueRescaled;
    }
    let newValue = (max - min) * valueRescaled + min;
    newValue = (0, _roundValueToStep.roundValueToStep)(newValue, step, min);
    newValue = (0, _clamp.clamp)(newValue, min, max);
    if (!range) {
      return {
        value: newValue,
        valueRescaled,
        percentageValues: [valueRescaled * 100],
        thumbIndex: 0
      };
    }
    if (shouldCaptureThumbIndex) {
      closestThumbIndexRef.current = findClosest(values, newValue) ?? 0;
    }
    const closestThumbIndex = closestThumbIndexRef.current ?? 0;

    // Bound the new value to the thumb's neighbours.
    newValue = (0, _clamp.clamp)(newValue, values[closestThumbIndex - 1] + minStepsBetweenValues || -Infinity, values[closestThumbIndex + 1] - minStepsBetweenValues || Infinity);
    return {
      value: (0, _replaceArrayItemAtIndex.replaceArrayItemAtIndex)(values, closestThumbIndex, newValue),
      valueRescaled,
      percentageValues: (0, _replaceArrayItemAtIndex.replaceArrayItemAtIndex)(percentageValues, closestThumbIndex, valueRescaled * 100),
      thumbIndex: closestThumbIndex
    };
  });
  (0, _useEnhancedEffect.useEnhancedEffect)(() => {
    if (valueProp === undefined || dragging) {
      return;
    }
    if (min >= max) {
      (0, _warn.warn)('Slider `max` must be greater than `min`');
    }
    if (typeof valueUnwrapped === 'number') {
      const newPercentageValue = (0, _clamp.clamp)((0, _valueToPercent.valueToPercent)(valueUnwrapped, min, max), 0, 100);
      if (newPercentageValue !== percentageValues[0] && !Number.isNaN(newPercentageValue)) {
        setPercentageValues([newPercentageValue]);
      }
    } else if (Array.isArray(valueUnwrapped)) {
      const newPercentageValues = valueArrayToPercentages(valueUnwrapped, min, max);
      if (!(0, _areArraysEqual.areArraysEqual)(newPercentageValues, percentageValues)) {
        setPercentageValues(newPercentageValues);
      }
    }
  }, [dragging, min, max, percentageValues, setPercentageValues, valueProp, valueUnwrapped]);
  (0, _useEnhancedEffect.useEnhancedEffect)(() => {
    const activeEl = (0, _utils.activeElement)((0, _owner.ownerDocument)(sliderRef.current));
    if (disabled && sliderRef.current?.contains(activeEl)) {
      // This is necessary because Firefox and Safari will keep focus
      // on a disabled element:
      // https://codesandbox.io/p/sandbox/mui-pr-22247-forked-h151h?file=/src/App.js
      // @ts-ignore
      activeEl.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  const getRootProps = React.useCallback((externalProps = {}) => (0, _mergeProps.mergeProps)({
    'aria-labelledby': ariaLabelledby,
    id,
    ref: handleRootRef,
    role: 'group'
  }, getValidationProps(externalProps)), [ariaLabelledby, getValidationProps, handleRootRef, id]);
  return React.useMemo(() => ({
    'aria-labelledby': ariaLabelledby,
    active,
    commitValue,
    disabled,
    dragging,
    getFingerState,
    getRootProps,
    handleInputChange,
    largeStep,
    lastChangedValueRef,
    max,
    min,
    minStepsBetweenValues,
    name,
    onValueCommitted,
    orientation,
    percentageValues,
    range,
    registerSliderControl,
    setActive,
    setDragging,
    setThumbMap,
    setValue,
    step,
    thumbMap,
    thumbRefs,
    values
  }), [active, ariaLabelledby, commitValue, disabled, dragging, getFingerState, getRootProps, handleInputChange, largeStep, lastChangedValueRef, max, min, minStepsBetweenValues, name, onValueCommitted, orientation, percentageValues, range, registerSliderControl, setActive, setDragging, setThumbMap, setValue, step, thumbMap, thumbRefs, values]);
}