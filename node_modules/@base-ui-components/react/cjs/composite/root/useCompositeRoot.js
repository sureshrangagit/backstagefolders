"use strict";
'use client';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCompositeRoot = useCompositeRoot;
var React = _interopRequireWildcard(require("react"));
var _isElementDisabled = require("../../utils/isElementDisabled");
var _mergeProps = require("../../merge-props");
var _useEventCallback = require("../../utils/useEventCallback");
var _useForkRef = require("../../utils/useForkRef");
var _composite = require("../composite");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function getDisallowedModifierKeys(modifierKeys) {
  if (modifierKeys.length === 1) {
    const keys = _composite.MODIFIER_KEYS.slice();
    keys.splice(keys.indexOf(modifierKeys[0]), 1);
    return keys;
  }
  const set = new Set(modifierKeys);
  return _composite.MODIFIER_KEYS.filter(key => !set.has(key));
}
const EMPTY_ARRAY = [];

/**
 * @ignore - internal hook.
 */
function useCompositeRoot(params) {
  const {
    itemSizes,
    cols = 1,
    loop = true,
    dense = false,
    orientation = 'both',
    direction,
    highlightedIndex: externalHighlightedIndex,
    onHighlightedIndexChange: externalSetHighlightedIndex,
    rootRef: externalRef,
    enableHomeAndEndKeys = false,
    stopEventPropagation = false,
    disabledIndices,
    modifierKeys = EMPTY_ARRAY
  } = params;
  const [internalHighlightedIndex, internalSetHighlightedIndex] = React.useState(0);
  const isGrid = cols > 1;
  const highlightedIndex = externalHighlightedIndex ?? internalHighlightedIndex;
  const onHighlightedIndexChange = (0, _useEventCallback.useEventCallback)(externalSetHighlightedIndex ?? internalSetHighlightedIndex);
  const textDirectionRef = React.useRef(direction ?? null);
  const rootRef = React.useRef(null);
  const mergedRef = (0, _useForkRef.useForkRef)(rootRef, externalRef);
  const elementsRef = React.useRef([]);
  const getRootProps = React.useCallback((externalProps = {}) => (0, _mergeProps.mergeProps)({
    'aria-orientation': orientation === 'both' ? undefined : orientation,
    ref: mergedRef,
    onFocus(event) {
      const element = rootRef.current;
      if (!element || !(0, _composite.isNativeInput)(event.target)) {
        return;
      }
      event.target.setSelectionRange(0, event.target.value.length ?? 0);
    },
    onKeyDown(event) {
      const RELEVANT_KEYS = enableHomeAndEndKeys ? _composite.ALL_KEYS : _composite.ARROW_KEYS;
      if (!RELEVANT_KEYS.includes(event.key)) {
        return;
      }
      if (modifierKeys.length === 0 && (event.shiftKey || event.ctrlKey || event.altKey || event.metaKey)) {
        return;
      }
      if (modifierKeys.length > 0 && getDisallowedModifierKeys(modifierKeys).some(key => event.getModifierState(key))) {
        return;
      }
      const element = rootRef.current;
      if (!element) {
        return;
      }
      if (event.target.closest('[data-floating-ui-portal]') != null) {
        // don't navigate if the event came from a popup
        return;
      }
      if (textDirectionRef?.current == null) {
        textDirectionRef.current = (0, _composite.getTextDirection)(element);
      }
      const isRtl = textDirectionRef.current === 'rtl';
      const horizontalForwardKey = isRtl ? _composite.ARROW_LEFT : _composite.ARROW_RIGHT;
      const forwardKey = {
        horizontal: horizontalForwardKey,
        vertical: _composite.ARROW_DOWN,
        both: horizontalForwardKey
      }[orientation];
      const horizontalBackwardKey = isRtl ? _composite.ARROW_RIGHT : _composite.ARROW_LEFT;
      const backwardKey = {
        horizontal: horizontalBackwardKey,
        vertical: _composite.ARROW_UP,
        both: horizontalBackwardKey
      }[orientation];
      if ((0, _composite.isNativeInput)(event.target) && !(0, _isElementDisabled.isElementDisabled)(event.target)) {
        const selectionStart = event.target.selectionStart;
        const selectionEnd = event.target.selectionEnd;
        const textContent = event.target.value ?? '';
        // return to native textbox behavior when
        // 1 - Shift is held to make a text selection, or if there already is a text selection
        if (selectionStart == null || event.shiftKey || selectionStart !== selectionEnd) {
          return;
        }
        // 2 - arrow-ing forward and not in the last position of the text
        if (event.key !== backwardKey && selectionStart < textContent.length) {
          return;
        }
        // 3 -arrow-ing backward and not in the first position of the text
        if (event.key !== forwardKey && selectionStart > 0) {
          return;
        }
      }
      let nextIndex = highlightedIndex;
      const minIndex = (0, _composite.getMinIndex)(elementsRef, disabledIndices);
      const maxIndex = (0, _composite.getMaxIndex)(elementsRef, disabledIndices);
      if (isGrid) {
        const sizes = itemSizes || Array.from({
          length: elementsRef.current.length
        }, () => ({
          width: 1,
          height: 1
        }));
        // To calculate movements on the grid, we use hypothetical cell indices
        // as if every item was 1x1, then convert back to real indices.
        const cellMap = (0, _composite.buildCellMap)(sizes, cols, dense);
        const minGridIndex = cellMap.findIndex(index => index != null && !(0, _composite.isDisabled)(elementsRef.current, index, disabledIndices));
        // last enabled index
        const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(0, _composite.isDisabled)(elementsRef.current, index, disabledIndices) ? cellIndex : foundIndex, -1);
        nextIndex = cellMap[(0, _composite.getGridNavigatedIndex)({
          current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)
        }, {
          event,
          orientation,
          loop,
          cols,
          // treat undefined (empty grid spaces) as disabled indices so we
          // don't end up in them
          disabledIndices: (0, _composite.getCellIndices)([...(disabledIndices || elementsRef.current.map((_, index) => (0, _composite.isDisabled)(elementsRef.current, index) ? index : undefined)), undefined], cellMap),
          minIndex: minGridIndex,
          maxIndex: maxGridIndex,
          prevIndex: (0, _composite.getCellIndexOfCorner)(highlightedIndex > maxIndex ? minIndex : highlightedIndex, sizes, cellMap, cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          // eslint-disable-next-line no-nested-ternary
          event.key === _composite.ARROW_DOWN ? 'bl' : event.key === _composite.ARROW_RIGHT ? 'tr' : 'tl'),
          rtl: isRtl
        })]; // navigated cell will never be nullish
      }
      const forwardKeys = {
        horizontal: [horizontalForwardKey],
        vertical: [_composite.ARROW_DOWN],
        both: [horizontalForwardKey, _composite.ARROW_DOWN]
      }[orientation];
      const backwardKeys = {
        horizontal: [horizontalBackwardKey],
        vertical: [_composite.ARROW_UP],
        both: [horizontalBackwardKey, _composite.ARROW_UP]
      }[orientation];
      const preventedKeys = isGrid ? RELEVANT_KEYS : {
        horizontal: enableHomeAndEndKeys ? _composite.HORIZONTAL_KEYS_WITH_EXTRA_KEYS : _composite.HORIZONTAL_KEYS,
        vertical: enableHomeAndEndKeys ? _composite.VERTICAL_KEYS_WITH_EXTRA_KEYS : _composite.VERTICAL_KEYS,
        both: RELEVANT_KEYS
      }[orientation];
      if (enableHomeAndEndKeys) {
        if (event.key === _composite.HOME) {
          nextIndex = minIndex;
        } else if (event.key === _composite.END) {
          nextIndex = maxIndex;
        }
      }
      if (nextIndex === highlightedIndex && [...forwardKeys, ...backwardKeys].includes(event.key)) {
        if (loop && nextIndex === maxIndex && forwardKeys.includes(event.key)) {
          nextIndex = minIndex;
        } else if (loop && nextIndex === minIndex && backwardKeys.includes(event.key)) {
          nextIndex = maxIndex;
        } else {
          nextIndex = (0, _composite.findNonDisabledIndex)(elementsRef, {
            startingIndex: nextIndex,
            decrement: backwardKeys.includes(event.key),
            disabledIndices
          });
        }
      }
      if (nextIndex !== highlightedIndex && !(0, _composite.isIndexOutOfBounds)(elementsRef, nextIndex)) {
        if (stopEventPropagation) {
          event.stopPropagation();
        }
        if (preventedKeys.includes(event.key)) {
          event.preventDefault();
        }
        onHighlightedIndexChange(nextIndex);

        // Wait for FocusManager `returnFocus` to execute.
        queueMicrotask(() => {
          elementsRef.current[nextIndex]?.focus();
        });
      }
    }
  }, externalProps), [cols, dense, disabledIndices, elementsRef, enableHomeAndEndKeys, highlightedIndex, isGrid, itemSizes, loop, mergedRef, modifierKeys, onHighlightedIndexChange, orientation, stopEventPropagation]);
  return React.useMemo(() => ({
    getRootProps,
    highlightedIndex,
    onHighlightedIndexChange,
    elementsRef,
    disabledIndices
  }), [getRootProps, highlightedIndex, onHighlightedIndexChange, elementsRef, disabledIndices]);
}