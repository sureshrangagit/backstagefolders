"use strict";
'use client';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useMenuTrigger = useMenuTrigger;
var React = _interopRequireWildcard(require("react"));
var _utils = require("@floating-ui/react/utils");
var _useButton = require("../../use-button/useButton");
var _useForkRef = require("../../utils/useForkRef");
var _mergeProps = require("../../merge-props");
var _owner = require("../../utils/owner");
var _getPseudoElementBounds = require("../../utils/getPseudoElementBounds");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function useMenuTrigger(parameters) {
  const BOUNDARY_OFFSET = 2;
  const {
    disabled = false,
    rootRef: externalRef,
    open,
    setOpen,
    setTriggerElement,
    positionerRef,
    allowMouseUpTriggerRef
  } = parameters;
  const triggerRef = React.useRef(null);
  const mergedRef = (0, _useForkRef.useForkRef)(externalRef, triggerRef);
  const allowMouseUpTriggerTimeoutRef = React.useRef(-1);
  const {
    getButtonProps,
    buttonRef
  } = (0, _useButton.useButton)({
    disabled,
    buttonRef: mergedRef
  });
  const handleRef = (0, _useForkRef.useForkRef)(buttonRef, setTriggerElement);
  React.useEffect(() => {
    if (!open) {
      allowMouseUpTriggerRef.current = false;
    }
  }, [allowMouseUpTriggerRef, open]);
  const getTriggerProps = React.useCallback(externalProps => {
    return (0, _mergeProps.mergeProps)({
      'aria-haspopup': 'menu',
      tabIndex: 0,
      // this is needed to make the button focused after click in Safari
      ref: handleRef,
      onMouseDown: event => {
        if (open) {
          return;
        }

        // mousedown -> mouseup on menu item should not trigger it within 200ms.
        allowMouseUpTriggerTimeoutRef.current = window.setTimeout(() => {
          allowMouseUpTriggerRef.current = true;
        }, 200);
        const doc = (0, _owner.ownerDocument)(event.currentTarget);
        function handleMouseUp(mouseEvent) {
          if (!triggerRef.current) {
            return;
          }
          if (allowMouseUpTriggerTimeoutRef.current !== -1) {
            clearTimeout(allowMouseUpTriggerTimeoutRef.current);
            allowMouseUpTriggerTimeoutRef.current = -1;
          }
          allowMouseUpTriggerRef.current = false;
          const mouseUpTarget = mouseEvent.target;
          if ((0, _utils.contains)(triggerRef.current, mouseUpTarget) || (0, _utils.contains)(positionerRef.current, mouseUpTarget) || mouseUpTarget === triggerRef.current) {
            return;
          }
          const bounds = (0, _getPseudoElementBounds.getPseudoElementBounds)(triggerRef.current);
          if (mouseEvent.clientX >= bounds.left - BOUNDARY_OFFSET && mouseEvent.clientX <= bounds.right + BOUNDARY_OFFSET && mouseEvent.clientY >= bounds.top - BOUNDARY_OFFSET && mouseEvent.clientY <= bounds.bottom + BOUNDARY_OFFSET) {
            return;
          }
          setOpen(false, mouseEvent);
        }
        doc.addEventListener('mouseup', handleMouseUp, {
          once: true
        });
      }
    }, externalProps, getButtonProps);
  }, [getButtonProps, handleRef, open, setOpen, positionerRef, allowMouseUpTriggerRef]);
  return React.useMemo(() => ({
    getTriggerProps,
    triggerRef: handleRef
  }), [getTriggerProps, handleRef]);
}