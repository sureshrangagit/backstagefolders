"use strict";
'use client';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useButton = useButton;
var React = _interopRequireWildcard(require("react"));
var _useForkRef = require("../utils/useForkRef");
var _mergeProps = require("../merge-props");
var _useEnhancedEffect = require("../utils/useEnhancedEffect");
var _useEventCallback = require("../utils/useEventCallback");
var _useRootElementName = require("../utils/useRootElementName");
var _CompositeRootContext = require("../composite/root/CompositeRootContext");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function useButton(parameters = {}) {
  const {
    buttonRef: externalRef,
    disabled = false,
    focusableWhenDisabled,
    tabIndex,
    type,
    elementName: elementNameProp
  } = parameters;
  const buttonRef = React.useRef(null);
  const {
    rootElementName: elementName,
    updateRootElementName
  } = (0, _useRootElementName.useRootElementName)({
    rootElementName: elementNameProp
  });
  const isCompositeItem = (0, _CompositeRootContext.useCompositeRootContext)(true) !== undefined;
  const isNativeButton = (0, _useEventCallback.useEventCallback)(() => {
    const element = buttonRef.current;
    return elementName === 'BUTTON' || elementName === 'INPUT' && ['button', 'submit', 'reset'].includes(element?.type);
  });
  const isValidLink = (0, _useEventCallback.useEventCallback)(() => {
    const element = buttonRef.current;
    return Boolean(elementName === 'A' && element?.href);
  });
  const mergedRef = (0, _useForkRef.useForkRef)(updateRootElementName, externalRef, buttonRef);
  const buttonProps = React.useMemo(() => {
    const additionalProps = {};
    if (tabIndex !== undefined && !isCompositeItem) {
      additionalProps.tabIndex = tabIndex;
    }
    if (elementName === 'BUTTON' || elementName === 'INPUT') {
      if (focusableWhenDisabled || isCompositeItem) {
        additionalProps['aria-disabled'] = disabled;
      } else if (!isCompositeItem) {
        additionalProps.disabled = disabled;
      }
    } else if (elementName !== '') {
      if (elementName !== 'A') {
        additionalProps.role = 'button';
        if (!isCompositeItem) {
          additionalProps.tabIndex = tabIndex ?? 0;
        }
      } else if (tabIndex && !isCompositeItem) {
        additionalProps.tabIndex = tabIndex;
      }
      if (disabled) {
        additionalProps['aria-disabled'] = disabled;
        if (!isCompositeItem) {
          additionalProps.tabIndex = focusableWhenDisabled ? tabIndex ?? 0 : -1;
        }
      }
    }
    return additionalProps;
  }, [disabled, elementName, focusableWhenDisabled, isCompositeItem, tabIndex]);

  // handles a disabled composite button rendering another button, e.g.
  // <Toolbar.Button disabled render={<Menu.Trigger />} />
  // the `disabled` prop needs to pass through 2 `useButton`s then finally
  // delete the `disabled` attribute from DOM
  (0, _useEnhancedEffect.useEnhancedEffect)(() => {
    const element = buttonRef.current;
    if (!(element instanceof HTMLButtonElement)) {
      return;
    }
    if (isCompositeItem && disabled && buttonProps.disabled === undefined && element.disabled) {
      element.disabled = false;
    }
  }, [disabled, buttonProps.disabled, isCompositeItem]);
  const getButtonProps = React.useCallback((externalProps = {}) => {
    const {
      onClick: externalOnClick,
      onMouseDown: externalOnMouseDown,
      onKeyUp: externalOnKeyUp,
      onKeyDown: externalOnKeyDown,
      onPointerDown: externalOnPointerDown,
      ...otherExternalProps
    } = externalProps;
    return (0, _mergeProps.mergeProps)({
      type,
      onClick(event) {
        if (disabled) {
          event.preventDefault();
          return;
        }
        externalOnClick?.(event);
      },
      onMouseDown(event) {
        if (!disabled) {
          externalOnMouseDown?.(event);
        }
      },
      onKeyDown(event) {
        if (
        // allow Tabbing away from focusableWhenDisabled buttons
        disabled && focusableWhenDisabled && event.key !== 'Tab' || event.target === event.currentTarget && !isNativeButton() && event.key === ' ') {
          event.preventDefault();
        }
        if (!disabled) {
          (0, _mergeProps.makeEventPreventable)(event);
          externalOnKeyDown?.(event);
        }
        if (event.baseUIHandlerPrevented) {
          return;
        }

        // Keyboard accessibility for non interactive elements
        if (event.target === event.currentTarget && !isNativeButton() && !isValidLink() && event.key === 'Enter' && !disabled) {
          externalOnClick?.(event);
          event.preventDefault();
        }
      },
      onKeyUp(event) {
        // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
        // https://codesandbox.io/p/sandbox/button-keyup-preventdefault-dn7f0
        // Keyboard accessibility for non interactive elements
        if (!disabled) {
          (0, _mergeProps.makeEventPreventable)(event);
          externalOnKeyUp?.(event);
        }
        if (event.baseUIHandlerPrevented) {
          return;
        }
        if (event.target === event.currentTarget && !isNativeButton() && !disabled && event.key === ' ') {
          externalOnClick?.(event);
        }
      },
      onPointerDown(event) {
        if (disabled) {
          event.preventDefault();
          return;
        }
        externalOnPointerDown?.(event);
      },
      ref: mergedRef
    }, buttonProps, otherExternalProps);
  }, [buttonProps, disabled, focusableWhenDisabled, isNativeButton, isValidLink, mergedRef, type]);
  return {
    getButtonProps,
    buttonRef: mergedRef
  };
}