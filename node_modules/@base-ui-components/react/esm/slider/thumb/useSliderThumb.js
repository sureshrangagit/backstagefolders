'use client';

import * as React from 'react';
import { formatNumber } from '../../utils/formatNumber.js';
import { mergeProps } from '../../merge-props/index.js';
import { useForkRef } from '../../utils/useForkRef.js';
import { visuallyHidden } from '../../utils/visuallyHidden.js';
import { ARROW_DOWN, ARROW_UP, ARROW_RIGHT, ARROW_LEFT, HOME, END } from '../../composite/composite.js';
import { useCompositeListItem } from '../../composite/list/useCompositeListItem.js';
import { useDirection } from '../../direction-provider/DirectionContext.js';
import { useFieldControlValidation } from '../../field/control/useFieldControlValidation.js';
import { useFieldRootContext } from '../../field/root/FieldRootContext.js';
import { getSliderValue } from '../utils/getSliderValue.js';
import { roundValueToStep } from '../utils/roundValueToStep.js';
function getNewValue(thumbValue, step, direction, min, max) {
  return direction === 1 ? Math.min(thumbValue + step, max) : Math.max(thumbValue - step, min);
}
function getDefaultAriaValueText(values, index, format) {
  if (index < 0) {
    return undefined;
  }
  if (values.length === 2) {
    if (index === 0) {
      return `${formatNumber(values[index], [], format)} start range`;
    }
    return `${formatNumber(values[index], [], format)} end range`;
  }
  return format ? formatNumber(values[index], [], format) : undefined;
}
export function useSliderThumb(parameters) {
  const {
    active: activeIndex,
    'aria-label': ariaLabel,
    'aria-labelledby': ariaLabelledby,
    'aria-valuetext': ariaValuetext,
    handleInputChange,
    disabled,
    format,
    getAriaLabel = null,
    getAriaValueText = null,
    id: thumbId,
    inputId,
    largeStep,
    max,
    min,
    minStepsBetweenValues,
    name,
    orientation,
    percentageValues,
    rootRef: externalRef,
    step,
    tabIndex: externalTabIndex,
    values: sliderValues
  } = parameters;
  const direction = useDirection();
  const {
    setTouched,
    setFocused,
    validationMode
  } = useFieldRootContext();
  const {
    getInputValidationProps,
    inputRef: inputValidationRef,
    commitValidation
  } = useFieldControlValidation();
  const thumbRef = React.useRef(null);
  const inputRef = React.useRef(null);
  const mergedInputRef = useForkRef(inputRef, inputValidationRef);
  const thumbMetadata = React.useMemo(() => ({
    inputId
  }), [inputId]);
  const {
    ref: listItemRef,
    index
  } = useCompositeListItem({
    metadata: thumbMetadata
  });
  const mergedThumbRef = useForkRef(externalRef, listItemRef, thumbRef);
  const thumbValue = sliderValues[index];

  // for SSR, don't wait for the index if there's only one thumb
  const percent = percentageValues.length === 1 ? percentageValues[0] : percentageValues[index];
  const isRtl = direction === 'rtl';
  const getThumbStyle = React.useCallback(() => {
    const isVertical = orientation === 'vertical';
    if (!Number.isFinite(percent)) {
      return visuallyHidden;
    }
    return {
      position: 'absolute',
      [{
        horizontal: 'insetInlineStart',
        vertical: 'bottom'
      }[orientation]]: `${percent}%`,
      [isVertical ? 'left' : 'top']: '50%',
      transform: `translate(${(isVertical || !isRtl ? -1 : 1) * 50}%, ${(isVertical ? 1 : -1) * 50}%)`,
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: activeIndex !== -1 && activeIndex !== index ? 'none' : undefined,
      zIndex: activeIndex === index ? 1 : undefined
    };
  }, [activeIndex, isRtl, orientation, percent, index]);
  const getRootProps = React.useCallback((externalProps = {}) => {
    return mergeProps({
      ['data-index']: index,
      id: thumbId,
      onFocus() {
        setFocused(true);
      },
      onBlur() {
        if (!thumbRef.current) {
          return;
        }
        setTouched(true);
        setFocused(false);
        if (validationMode === 'onBlur') {
          commitValidation(getSliderValue(thumbValue, index, min, max, sliderValues.length > 1, sliderValues));
        }
      },
      onKeyDown(event) {
        let newValue = null;
        const isRange = sliderValues.length > 1;
        const roundedValue = roundValueToStep(thumbValue, step, min);
        switch (event.key) {
          case ARROW_UP:
            newValue = getNewValue(roundedValue, event.shiftKey ? largeStep : step, 1, min, max);
            break;
          case ARROW_RIGHT:
            newValue = getNewValue(roundedValue, event.shiftKey ? largeStep : step, isRtl ? -1 : 1, min, max);
            break;
          case ARROW_DOWN:
            newValue = getNewValue(roundedValue, event.shiftKey ? largeStep : step, -1, min, max);
            break;
          case ARROW_LEFT:
            newValue = getNewValue(roundedValue, event.shiftKey ? largeStep : step, isRtl ? 1 : -1, min, max);
            break;
          case 'PageUp':
            newValue = getNewValue(roundedValue, largeStep, 1, min, max);
            break;
          case 'PageDown':
            newValue = getNewValue(roundedValue, largeStep, -1, min, max);
            break;
          case END:
            newValue = max;
            if (isRange) {
              newValue = Number.isFinite(sliderValues[index + 1]) ? sliderValues[index + 1] - step * minStepsBetweenValues : max;
            }
            break;
          case HOME:
            newValue = min;
            if (isRange) {
              newValue = Number.isFinite(sliderValues[index - 1]) ? sliderValues[index - 1] + step * minStepsBetweenValues : min;
            }
            break;
          default:
            break;
        }
        if (newValue !== null) {
          handleInputChange(newValue, index, event);
          event.preventDefault();
        }
      },
      ref: mergedThumbRef,
      style: getThumbStyle(),
      tabIndex: externalTabIndex ?? (disabled ? undefined : 0)
    }, externalProps);
  }, [commitValidation, disabled, externalTabIndex, getThumbStyle, handleInputChange, index, isRtl, largeStep, max, mergedThumbRef, min, minStepsBetweenValues, setFocused, setTouched, sliderValues, step, thumbId, thumbValue, validationMode]);
  const getThumbInputProps = React.useCallback((externalProps = {}) => {
    let cssWritingMode;
    if (orientation === 'vertical') {
      cssWritingMode = isRtl ? 'vertical-rl' : 'vertical-lr';
    }
    return mergeProps({
      'aria-label': getAriaLabel != null ? getAriaLabel(index) : ariaLabel,
      'aria-labelledby': ariaLabelledby,
      'aria-orientation': orientation,
      'aria-valuemax': max,
      'aria-valuemin': min,
      'aria-valuenow': thumbValue,
      'aria-valuetext': getAriaValueText != null ? getAriaValueText(formatNumber(thumbValue, [], format ?? undefined), thumbValue, index) : ariaValuetext || getDefaultAriaValueText(sliderValues, index, format ?? undefined),
      ['data-index']: index,
      disabled,
      id: inputId,
      max,
      min,
      name,
      onChange(event) {
        handleInputChange(event.target.valueAsNumber, index, event);
      },
      ref: mergedInputRef,
      step,
      style: {
        ...visuallyHidden,
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: '100%',
        height: '100%',
        writingMode: cssWritingMode
      },
      tabIndex: -1,
      type: 'range',
      value: thumbValue ?? ''
    }, getInputValidationProps(externalProps));
  }, [ariaLabel, ariaLabelledby, ariaValuetext, handleInputChange, disabled, format, getAriaLabel, getAriaValueText, getInputValidationProps, index, isRtl, max, mergedInputRef, min, name, orientation, sliderValues, step, inputId, thumbValue]);
  return React.useMemo(() => ({
    getRootProps,
    getThumbInputProps,
    disabled,
    index
  }), [getRootProps, getThumbInputProps, disabled, index]);
}