'use client';

import * as React from 'react';
import { activeElement } from '@floating-ui/react/utils';
import { areArraysEqual } from '../../utils/areArraysEqual.js';
import { clamp } from '../../utils/clamp.js';
import { mergeProps } from '../../merge-props/index.js';
import { ownerDocument } from '../../utils/owner.js';
import { useControlled } from '../../utils/useControlled.js';
import { useEnhancedEffect } from '../../utils/useEnhancedEffect.js';
import { useForkRef } from '../../utils/useForkRef.js';
import { valueToPercent } from '../../utils/valueToPercent.js';
import { warn } from '../../utils/warn.js';
import { useDirection } from '../../direction-provider/DirectionContext.js';
import { useField } from '../../field/useField.js';
import { useFieldRootContext } from '../../field/root/FieldRootContext.js';
import { useFieldControlValidation } from '../../field/control/useFieldControlValidation.js';
import { asc } from '../utils/asc.js';
import { getSliderValue } from '../utils/getSliderValue.js';
import { replaceArrayItemAtIndex } from '../utils/replaceArrayItemAtIndex.js';
import { roundValueToStep } from '../utils/roundValueToStep.js';
import { useEventCallback } from '../../utils/useEventCallback.js';
function areValuesEqual(newValue, oldValue) {
  if (typeof newValue === 'number' && typeof oldValue === 'number') {
    return newValue === oldValue;
  }
  if (Array.isArray(newValue) && Array.isArray(oldValue)) {
    return areArraysEqual(newValue, oldValue);
  }
  return false;
}
function findClosest(values, currentValue) {
  const {
    index: closestIndex
  } = values.reduce((acc, value, index) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index
      };
    }
    return acc;
  }, null) ?? {};
  return closestIndex;
}
function valueArrayToPercentages(values, min, max) {
  const output = [];
  for (let i = 0; i < values.length; i += 1) {
    output.push(clamp(valueToPercent(values[i], min, max), 0, 100));
  }
  return output;
}
export function focusThumb(thumbIndex, sliderRef, setActive) {
  if (!sliderRef.current) {
    return;
  }
  const doc = ownerDocument(sliderRef.current);
  if (!sliderRef.current.contains(doc.activeElement) || Number(doc?.activeElement?.getAttribute('data-index')) !== thumbIndex) {
    sliderRef.current.querySelector(`[type="range"][data-index="${thumbIndex}"]`).focus();
  }
  if (setActive) {
    setActive(thumbIndex);
  }
}
export function validateMinimumDistance(values, step, minStepsBetweenValues) {
  if (!Array.isArray(values)) {
    return true;
  }
  const distances = values.reduce((acc, val, index, vals) => {
    if (index === vals.length - 1) {
      return acc;
    }
    acc.push(Math.abs(val - vals[index + 1]));
    return acc;
  }, []);
  return Math.min(...distances) >= step * minStepsBetweenValues;
}

/**
 */
export function useSliderRoot(parameters) {
  const {
    'aria-labelledby': ariaLabelledby,
    defaultValue,
    disabled = false,
    id,
    largeStep = 10,
    max = 100,
    min = 0,
    minStepsBetweenValues = 0,
    name,
    onValueChange,
    onValueCommitted,
    orientation = 'horizontal',
    rootRef,
    step = 1,
    value: valueProp
  } = parameters;
  const direction = useDirection();
  const {
    setControlId,
    setTouched,
    setDirty,
    validityData,
    validationMode
  } = useFieldRootContext();
  const {
    getValidationProps,
    inputRef: inputValidationRef,
    commitValidation
  } = useFieldControlValidation();

  // The internal value is potentially unsorted, e.g. to support frozen arrays
  // https://github.com/mui/material-ui/pull/28472
  const [valueUnwrapped, setValueUnwrapped] = useControlled({
    controlled: valueProp,
    default: defaultValue ?? min,
    name: 'Slider'
  });
  const sliderRef = React.useRef(null);
  const controlRef = React.useRef(null);
  const thumbRefs = React.useRef([]);
  const lastChangedValueRef = React.useRef(null);
  const [thumbMap, setThumbMap] = React.useState(() => new Map());
  useEnhancedEffect(() => {
    setControlId(id);
    return () => {
      setControlId(undefined);
    };
  }, [id, setControlId]);
  useField({
    id,
    commitValidation,
    value: valueUnwrapped,
    controlRef
  });

  // We can't use the :active browser pseudo-classes.
  // - The active state isn't triggered when clicking on the rail.
  // - The active state isn't transferred when inversing a range slider.
  const [active, setActive] = React.useState(-1);
  const [dragging, setDragging] = React.useState(false);
  const registerSliderControl = React.useCallback(element => {
    if (element) {
      controlRef.current = element;
      inputValidationRef.current = element.querySelector('input[type="range"]');
    }
  }, [inputValidationRef]);
  const range = Array.isArray(valueUnwrapped);
  const values = React.useMemo(() => {
    if (!range) {
      return [clamp(valueUnwrapped, min, max)];
    }
    return valueUnwrapped.slice().sort(asc);
  }, [max, min, range, valueUnwrapped]);
  function initializePercentageValues() {
    return valueArrayToPercentages(values, min, max);
  }
  const [percentageValues, setPercentageValues] = React.useState(initializePercentageValues);
  const setValue = useEventCallback((newValue, newPercentageValues, thumbIndex, event) => {
    if (Number.isNaN(newValue) || areValuesEqual(newValue, valueUnwrapped)) {
      return;
    }
    setValueUnwrapped(newValue);
    setPercentageValues(newPercentageValues);
    // Redefine target to allow name and value to be read.
    // This allows seamless integration with the most popular form libraries.
    // https://github.com/mui/material-ui/issues/13485#issuecomment-676048492
    // Clone the event to not override `target` of the original event.
    // @ts-ignore The nativeEvent is function, not object
    const clonedEvent = new event.constructor(event.type, event);
    Object.defineProperty(clonedEvent, 'target', {
      writable: true,
      value: {
        value: newValue,
        name
      }
    });
    lastChangedValueRef.current = newValue;
    onValueChange(newValue, clonedEvent, thumbIndex);
  });

  // for pointer drag only
  const commitValue = useEventCallback((value, event) => {
    if (Array.isArray(value)) {
      const newPercentageValues = valueArrayToPercentages(value, min, max);
      if (!areArraysEqual(newPercentageValues, percentageValues)) {
        setPercentageValues(newPercentageValues);
      }
    } else if (typeof value === 'number') {
      setPercentageValues([valueToPercent(value, min, max)]);
    }
    onValueCommitted(value, event);
  });
  const handleRootRef = useForkRef(rootRef, sliderRef);

  // for keypresses only
  const handleInputChange = useEventCallback((valueInput, index, event) => {
    const newValue = getSliderValue(valueInput, index, min, max, range, values);
    if (range) {
      focusThumb(index, sliderRef);
    }
    if (validateMinimumDistance(newValue, step, minStepsBetweenValues)) {
      if (Array.isArray(newValue)) {
        setValue(newValue, replaceArrayItemAtIndex(percentageValues, index, valueToPercent(newValue[index], min, max)), index, event.nativeEvent);
      } else {
        setValue(newValue, [valueToPercent(newValue, min, max)], index, event.nativeEvent);
      }
      setDirty(newValue !== validityData.initialValue);
      setTouched(true);
      onValueCommitted(lastChangedValueRef.current ?? newValue, event.nativeEvent);
      if (validationMode === 'onChange') {
        commitValidation(lastChangedValueRef.current ?? newValue);
      }
    }
  });
  const closestThumbIndexRef = React.useRef(null);
  const getFingerState = useEventCallback((fingerPosition,
  /**
   * When `true`, closestThumbIndexRef is updated.
   * It's `true` when called by touchstart or pointerdown.
   */
  shouldCaptureThumbIndex = false,
  /**
   * The difference between the value at the finger origin and the value at
   * the center of the thumb scaled down to fit the range [0, 1]
   */
  offset = 0) => {
    if (fingerPosition == null) {
      return null;
    }
    const {
      current: sliderControl
    } = controlRef;
    if (!sliderControl) {
      return null;
    }
    const isRtl = direction === 'rtl';
    const isVertical = orientation === 'vertical';
    const {
      width,
      height,
      bottom,
      left
    } = sliderControl.getBoundingClientRect();

    // the value at the finger origin scaled down to fit the range [0, 1]
    let valueRescaled = isVertical ? (bottom - fingerPosition.y) / height + offset : (fingerPosition.x - left) / width + offset * (isRtl ? -1 : 1);
    valueRescaled = clamp(valueRescaled, 0, 1);
    if (isRtl && !isVertical) {
      valueRescaled = 1 - valueRescaled;
    }
    let newValue = (max - min) * valueRescaled + min;
    newValue = roundValueToStep(newValue, step, min);
    newValue = clamp(newValue, min, max);
    if (!range) {
      return {
        value: newValue,
        valueRescaled,
        percentageValues: [valueRescaled * 100],
        thumbIndex: 0
      };
    }
    if (shouldCaptureThumbIndex) {
      closestThumbIndexRef.current = findClosest(values, newValue) ?? 0;
    }
    const closestThumbIndex = closestThumbIndexRef.current ?? 0;

    // Bound the new value to the thumb's neighbours.
    newValue = clamp(newValue, values[closestThumbIndex - 1] + minStepsBetweenValues || -Infinity, values[closestThumbIndex + 1] - minStepsBetweenValues || Infinity);
    return {
      value: replaceArrayItemAtIndex(values, closestThumbIndex, newValue),
      valueRescaled,
      percentageValues: replaceArrayItemAtIndex(percentageValues, closestThumbIndex, valueRescaled * 100),
      thumbIndex: closestThumbIndex
    };
  });
  useEnhancedEffect(() => {
    if (valueProp === undefined || dragging) {
      return;
    }
    if (min >= max) {
      warn('Slider `max` must be greater than `min`');
    }
    if (typeof valueUnwrapped === 'number') {
      const newPercentageValue = clamp(valueToPercent(valueUnwrapped, min, max), 0, 100);
      if (newPercentageValue !== percentageValues[0] && !Number.isNaN(newPercentageValue)) {
        setPercentageValues([newPercentageValue]);
      }
    } else if (Array.isArray(valueUnwrapped)) {
      const newPercentageValues = valueArrayToPercentages(valueUnwrapped, min, max);
      if (!areArraysEqual(newPercentageValues, percentageValues)) {
        setPercentageValues(newPercentageValues);
      }
    }
  }, [dragging, min, max, percentageValues, setPercentageValues, valueProp, valueUnwrapped]);
  useEnhancedEffect(() => {
    const activeEl = activeElement(ownerDocument(sliderRef.current));
    if (disabled && sliderRef.current?.contains(activeEl)) {
      // This is necessary because Firefox and Safari will keep focus
      // on a disabled element:
      // https://codesandbox.io/p/sandbox/mui-pr-22247-forked-h151h?file=/src/App.js
      // @ts-ignore
      activeEl.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  const getRootProps = React.useCallback((externalProps = {}) => mergeProps({
    'aria-labelledby': ariaLabelledby,
    id,
    ref: handleRootRef,
    role: 'group'
  }, getValidationProps(externalProps)), [ariaLabelledby, getValidationProps, handleRootRef, id]);
  return React.useMemo(() => ({
    'aria-labelledby': ariaLabelledby,
    active,
    commitValue,
    disabled,
    dragging,
    getFingerState,
    getRootProps,
    handleInputChange,
    largeStep,
    lastChangedValueRef,
    max,
    min,
    minStepsBetweenValues,
    name,
    onValueCommitted,
    orientation,
    percentageValues,
    range,
    registerSliderControl,
    setActive,
    setDragging,
    setThumbMap,
    setValue,
    step,
    thumbMap,
    thumbRefs,
    values
  }), [active, ariaLabelledby, commitValue, disabled, dragging, getFingerState, getRootProps, handleInputChange, largeStep, lastChangedValueRef, max, min, minStepsBetweenValues, name, onValueCommitted, orientation, percentageValues, range, registerSliderControl, setActive, setDragging, setThumbMap, setValue, step, thumbMap, thumbRefs, values]);
}