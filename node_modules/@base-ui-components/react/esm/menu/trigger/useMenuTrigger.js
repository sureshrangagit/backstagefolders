'use client';

import * as React from 'react';
import { contains } from '@floating-ui/react/utils';
import { useButton } from '../../use-button/useButton.js';
import { useForkRef } from '../../utils/useForkRef.js';
import { mergeProps } from '../../merge-props/index.js';
import { ownerDocument } from '../../utils/owner.js';
import { getPseudoElementBounds } from '../../utils/getPseudoElementBounds.js';
export function useMenuTrigger(parameters) {
  const BOUNDARY_OFFSET = 2;
  const {
    disabled = false,
    rootRef: externalRef,
    open,
    setOpen,
    setTriggerElement,
    positionerRef,
    allowMouseUpTriggerRef
  } = parameters;
  const triggerRef = React.useRef(null);
  const mergedRef = useForkRef(externalRef, triggerRef);
  const allowMouseUpTriggerTimeoutRef = React.useRef(-1);
  const {
    getButtonProps,
    buttonRef
  } = useButton({
    disabled,
    buttonRef: mergedRef
  });
  const handleRef = useForkRef(buttonRef, setTriggerElement);
  React.useEffect(() => {
    if (!open) {
      allowMouseUpTriggerRef.current = false;
    }
  }, [allowMouseUpTriggerRef, open]);
  const getTriggerProps = React.useCallback(externalProps => {
    return mergeProps({
      'aria-haspopup': 'menu',
      tabIndex: 0,
      // this is needed to make the button focused after click in Safari
      ref: handleRef,
      onMouseDown: event => {
        if (open) {
          return;
        }

        // mousedown -> mouseup on menu item should not trigger it within 200ms.
        allowMouseUpTriggerTimeoutRef.current = window.setTimeout(() => {
          allowMouseUpTriggerRef.current = true;
        }, 200);
        const doc = ownerDocument(event.currentTarget);
        function handleMouseUp(mouseEvent) {
          if (!triggerRef.current) {
            return;
          }
          if (allowMouseUpTriggerTimeoutRef.current !== -1) {
            clearTimeout(allowMouseUpTriggerTimeoutRef.current);
            allowMouseUpTriggerTimeoutRef.current = -1;
          }
          allowMouseUpTriggerRef.current = false;
          const mouseUpTarget = mouseEvent.target;
          if (contains(triggerRef.current, mouseUpTarget) || contains(positionerRef.current, mouseUpTarget) || mouseUpTarget === triggerRef.current) {
            return;
          }
          const bounds = getPseudoElementBounds(triggerRef.current);
          if (mouseEvent.clientX >= bounds.left - BOUNDARY_OFFSET && mouseEvent.clientX <= bounds.right + BOUNDARY_OFFSET && mouseEvent.clientY >= bounds.top - BOUNDARY_OFFSET && mouseEvent.clientY <= bounds.bottom + BOUNDARY_OFFSET) {
            return;
          }
          setOpen(false, mouseEvent);
        }
        doc.addEventListener('mouseup', handleMouseUp, {
          once: true
        });
      }
    }, externalProps, getButtonProps);
  }, [getButtonProps, handleRef, open, setOpen, positionerRef, allowMouseUpTriggerRef]);
  return React.useMemo(() => ({
    getTriggerProps,
    triggerRef: handleRef
  }), [getTriggerProps, handleRef]);
}