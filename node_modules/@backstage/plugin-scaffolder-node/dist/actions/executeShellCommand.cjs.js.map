{"version":3,"file":"executeShellCommand.cjs.js","sources":["../../src/actions/executeShellCommand.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { LoggerService } from '@backstage/backend-plugin-api';\nimport { spawn, SpawnOptionsWithoutStdio } from 'child_process';\nimport { PassThrough, Writable } from 'stream';\n\n/**\n * Options for {@link executeShellCommand}.\n *\n * @public\n */\nexport type ExecuteShellCommandOptions = {\n  /** command to run */\n  command: string;\n  /** arguments to pass the command */\n  args: string[];\n  /** options to pass to spawn */\n  options?: SpawnOptionsWithoutStdio;\n  /** logger to capture stdout and stderr output */\n  logger?: LoggerService;\n  /**\n   * stream to capture stdout and stderr output\n   * @deprecated  please provide a logger instead.\n   */\n  logStream?: Writable;\n};\n\n/**\n * Run a command in a sub-process, normally a shell command.\n *\n * @public\n */\nexport async function executeShellCommand(\n  options: ExecuteShellCommandOptions,\n): Promise<void> {\n  const {\n    command,\n    args,\n    options: spawnOptions,\n    logger,\n    logStream = new PassThrough(),\n  } = options;\n\n  await new Promise<void>((resolve, reject) => {\n    const process = spawn(command, args, spawnOptions);\n\n    process.stdout.on('data', chunk => {\n      logStream?.write(chunk);\n      logger?.info(\n        Buffer.isBuffer(chunk) ? chunk.toString('utf8').trim() : chunk.trim(),\n      );\n    });\n    process.stderr.on('data', chunk => {\n      logStream?.write(chunk);\n      logger?.error(\n        Buffer.isBuffer(chunk) ? chunk.toString('utf8').trim() : chunk.trim(),\n      );\n    });\n    process.on('error', error => {\n      return reject(error);\n    });\n\n    process.on('close', code => {\n      if (code !== 0) {\n        return reject(\n          new Error(`Command ${command} failed, exit code: ${code}`),\n        );\n      }\n      return resolve();\n    });\n  });\n}\n"],"names":["PassThrough","spawn"],"mappings":";;;;;AA8CA,eAAsB,oBACpB,OACe,EAAA;AACf,EAAM,MAAA;AAAA,IACJ,OAAA;AAAA,IACA,IAAA;AAAA,IACA,OAAS,EAAA,YAAA;AAAA,IACT,MAAA;AAAA,IACA,SAAA,GAAY,IAAIA,kBAAY;AAAA,GAC1B,GAAA,OAAA;AAEJ,EAAA,MAAM,IAAI,OAAA,CAAc,CAAC,OAAA,EAAS,MAAW,KAAA;AAC3C,IAAA,MAAM,OAAU,GAAAC,mBAAA,CAAM,OAAS,EAAA,IAAA,EAAM,YAAY,CAAA;AAEjD,IAAQ,OAAA,CAAA,MAAA,CAAO,EAAG,CAAA,MAAA,EAAQ,CAAS,KAAA,KAAA;AACjC,MAAA,SAAA,EAAW,MAAM,KAAK,CAAA;AACtB,MAAQ,MAAA,EAAA,IAAA;AAAA,QACN,MAAA,CAAO,QAAS,CAAA,KAAK,CAAI,GAAA,KAAA,CAAM,QAAS,CAAA,MAAM,CAAE,CAAA,IAAA,EAAS,GAAA,KAAA,CAAM,IAAK;AAAA,OACtE;AAAA,KACD,CAAA;AACD,IAAQ,OAAA,CAAA,MAAA,CAAO,EAAG,CAAA,MAAA,EAAQ,CAAS,KAAA,KAAA;AACjC,MAAA,SAAA,EAAW,MAAM,KAAK,CAAA;AACtB,MAAQ,MAAA,EAAA,KAAA;AAAA,QACN,MAAA,CAAO,QAAS,CAAA,KAAK,CAAI,GAAA,KAAA,CAAM,QAAS,CAAA,MAAM,CAAE,CAAA,IAAA,EAAS,GAAA,KAAA,CAAM,IAAK;AAAA,OACtE;AAAA,KACD,CAAA;AACD,IAAQ,OAAA,CAAA,EAAA,CAAG,SAAS,CAAS,KAAA,KAAA;AAC3B,MAAA,OAAO,OAAO,KAAK,CAAA;AAAA,KACpB,CAAA;AAED,IAAQ,OAAA,CAAA,EAAA,CAAG,SAAS,CAAQ,IAAA,KAAA;AAC1B,MAAA,IAAI,SAAS,CAAG,EAAA;AACd,QAAO,OAAA,MAAA;AAAA,UACL,IAAI,KAAM,CAAA,CAAA,QAAA,EAAW,OAAO,CAAA,oBAAA,EAAuB,IAAI,CAAE,CAAA;AAAA,SAC3D;AAAA;AAEF,MAAA,OAAO,OAAQ,EAAA;AAAA,KAChB,CAAA;AAAA,GACF,CAAA;AACH;;;;"}