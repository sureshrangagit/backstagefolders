'use strict';

var errors = require('@backstage/errors');
var PQueue = require('p-queue');
var NunjucksWorkflowRunner = require('./NunjucksWorkflowRunner.cjs.js');
var promises = require('timers/promises');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var PQueue__default = /*#__PURE__*/_interopDefaultCompat(PQueue);

class TaskWorker {
  constructor(options) {
    this.options = options;
    this.stopWorkers = false;
    this.logger = options.logger;
    this.auditor = options.auditor;
    this.taskQueue = new PQueue__default.default({
      concurrency: options.concurrentTasksLimit
    });
  }
  taskQueue;
  logger;
  auditor;
  stopWorkers;
  static async create(options) {
    const {
      taskBroker,
      logger,
      auditor,
      actionRegistry,
      integrations,
      workingDirectory,
      additionalTemplateFilters,
      concurrentTasksLimit = 10,
      // from 1 to Infinity
      additionalTemplateGlobals,
      permissions,
      gracefulShutdown
    } = options;
    const workflowRunner = new NunjucksWorkflowRunner.NunjucksWorkflowRunner({
      actionRegistry,
      integrations,
      logger,
      auditor,
      workingDirectory,
      additionalTemplateFilters,
      additionalTemplateGlobals,
      permissions
    });
    return new TaskWorker({
      taskBroker,
      runners: { workflowRunner },
      concurrentTasksLimit,
      permissions,
      auditor,
      gracefulShutdown
    });
  }
  async recoverTasks() {
    try {
      await this.options.taskBroker.recoverTasks?.();
    } catch (err) {
      this.logger?.error(errors.stringifyError(err));
    }
  }
  start() {
    (async () => {
      while (!this.stopWorkers) {
        await promises.setTimeout(1e4);
        await this.recoverTasks();
      }
    })();
    (async () => {
      while (!this.stopWorkers) {
        await this.onReadyToClaimTask();
        if (!this.stopWorkers) {
          const task = await this.options.taskBroker.claim();
          void this.taskQueue.add(() => this.runOneTask(task));
        }
      }
    })();
  }
  async stop() {
    this.stopWorkers = true;
    if (this.options?.gracefulShutdown) {
      while (this.taskQueue.size > 0) {
        await promises.setTimeout(1e3);
      }
    }
  }
  onReadyToClaimTask() {
    if (this.taskQueue.pending < this.options.concurrentTasksLimit) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      this.taskQueue.once("next", () => {
        resolve();
      });
    });
  }
  async runOneTask(task) {
    const auditorEvent = await this.auditor?.createEvent({
      eventId: "task",
      severityLevel: "medium",
      meta: {
        actionType: "execution",
        taskId: task.taskId,
        taskParameters: task.spec.parameters,
        templateRef: task.spec.templateInfo?.entityRef
      }
    });
    try {
      if (task.spec.apiVersion !== "scaffolder.backstage.io/v1beta3") {
        throw new Error(
          `Unsupported Template apiVersion ${task.spec.apiVersion}`
        );
      }
      const { output } = await this.options.runners.workflowRunner.execute(
        task
      );
      await task.complete("completed", { output });
      await auditorEvent?.success();
    } catch (error) {
      errors.assertError(error);
      await auditorEvent?.fail({
        error
      });
      await task.complete("failed", {
        error: { name: error.name, message: error.message }
      });
    }
  }
}

exports.TaskWorker = TaskWorker;
//# sourceMappingURL=TaskWorker.cjs.js.map
