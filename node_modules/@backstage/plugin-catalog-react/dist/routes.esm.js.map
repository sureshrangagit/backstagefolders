{"version":3,"file":"routes.esm.js","sources":["../src/routes.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Entity,\n  DEFAULT_NAMESPACE,\n  CompoundEntityRef,\n  parseEntityRef,\n} from '@backstage/catalog-model';\nimport { createRouteRef } from '@backstage/core-plugin-api';\nimport { getOrCreateGlobalSingleton } from '@backstage/version-bridge';\n\n/**\n * A stable route ref that points to the catalog page for an individual entity.\n *\n * This `RouteRef` can be imported and used directly, and does not need to be referenced\n * via an `ExternalRouteRef`.\n *\n * If you want to replace the `EntityPage` from `@backstage/catalog-plugin` in your app,\n * you need to use the `entityRouteRef` as the mount point instead of your own.\n * @public\n */\nexport const entityRouteRef = getOrCreateGlobalSingleton(\n  'catalog:entity-route-ref',\n  () =>\n    createRouteRef({\n      id: 'catalog:entity',\n      params: ['namespace', 'kind', 'name'],\n    }),\n);\n\n/**\n * Configurable options for `entityRouteParams`\n * @public\n */\nexport type EntityRouteParamsOptions = {\n  encodeParams?: boolean;\n};\n\n/**\n * Utility function to get suitable route params for entityRoute, given an\n * @public\n */\nexport function entityRouteParams(\n  entityOrRef: Entity | CompoundEntityRef | string,\n  options?: EntityRouteParamsOptions,\n) {\n  let kind;\n  let namespace;\n  let name;\n\n  if (typeof entityOrRef === 'string') {\n    const parsed = parseEntityRef(entityOrRef);\n    kind = parsed.kind;\n    namespace = parsed.namespace;\n    name = parsed.name;\n  } else if ('metadata' in entityOrRef) {\n    kind = entityOrRef.kind;\n    namespace = entityOrRef.metadata.namespace;\n    name = entityOrRef.metadata.name;\n  } else {\n    kind = entityOrRef.kind;\n    namespace = entityOrRef.namespace;\n    name = entityOrRef.name;\n  }\n\n  kind = kind.toLocaleLowerCase('en-US');\n  namespace = namespace?.toLocaleLowerCase('en-US') ?? DEFAULT_NAMESPACE;\n\n  const { encodeParams = false } = options || {};\n  if (encodeParams) {\n    kind = encodeURIComponent(kind);\n    namespace = encodeURIComponent(namespace);\n    name = encodeURIComponent(name);\n  }\n\n  return {\n    kind,\n    namespace,\n    name,\n  } as const;\n}\n"],"names":[],"mappings":";;;;AAmCO,MAAM,cAAiB,GAAA,0BAAA;AAAA,EAC5B,0BAAA;AAAA,EACA,MACE,cAAe,CAAA;AAAA,IACb,EAAI,EAAA,gBAAA;AAAA,IACJ,MAAQ,EAAA,CAAC,WAAa,EAAA,MAAA,EAAQ,MAAM;AAAA,GACrC;AACL;AAcgB,SAAA,iBAAA,CACd,aACA,OACA,EAAA;AACA,EAAI,IAAA,IAAA;AACJ,EAAI,IAAA,SAAA;AACJ,EAAI,IAAA,IAAA;AAEJ,EAAI,IAAA,OAAO,gBAAgB,QAAU,EAAA;AACnC,IAAM,MAAA,MAAA,GAAS,eAAe,WAAW,CAAA;AACzC,IAAA,IAAA,GAAO,MAAO,CAAA,IAAA;AACd,IAAA,SAAA,GAAY,MAAO,CAAA,SAAA;AACnB,IAAA,IAAA,GAAO,MAAO,CAAA,IAAA;AAAA,GAChB,MAAA,IAAW,cAAc,WAAa,EAAA;AACpC,IAAA,IAAA,GAAO,WAAY,CAAA,IAAA;AACnB,IAAA,SAAA,GAAY,YAAY,QAAS,CAAA,SAAA;AACjC,IAAA,IAAA,GAAO,YAAY,QAAS,CAAA,IAAA;AAAA,GACvB,MAAA;AACL,IAAA,IAAA,GAAO,WAAY,CAAA,IAAA;AACnB,IAAA,SAAA,GAAY,WAAY,CAAA,SAAA;AACxB,IAAA,IAAA,GAAO,WAAY,CAAA,IAAA;AAAA;AAGrB,EAAO,IAAA,GAAA,IAAA,CAAK,kBAAkB,OAAO,CAAA;AACrC,EAAY,SAAA,GAAA,SAAA,EAAW,iBAAkB,CAAA,OAAO,CAAK,IAAA,iBAAA;AAErD,EAAA,MAAM,EAAE,YAAA,GAAe,KAAM,EAAA,GAAI,WAAW,EAAC;AAC7C,EAAA,IAAI,YAAc,EAAA;AAChB,IAAA,IAAA,GAAO,mBAAmB,IAAI,CAAA;AAC9B,IAAA,SAAA,GAAY,mBAAmB,SAAS,CAAA;AACxC,IAAA,IAAA,GAAO,mBAAmB,IAAI,CAAA;AAAA;AAGhC,EAAO,OAAA;AAAA,IACL,IAAA;AAAA,IACA,SAAA;AAAA,IACA;AAAA,GACF;AACF;;;;"}