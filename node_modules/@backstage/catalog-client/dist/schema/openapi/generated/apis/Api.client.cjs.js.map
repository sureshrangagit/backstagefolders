{"version":3,"file":"Api.client.cjs.js","sources":["../../../../../src/schema/openapi/generated/apis/Api.client.ts"],"sourcesContent":["/*\n * Copyright 2025 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// ******************************************************************\n// * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. *\n// ******************************************************************\nimport { DiscoveryApi } from '../types/discovery';\nimport { FetchApi } from '../types/fetch';\nimport crossFetch from 'cross-fetch';\nimport { pluginId } from '../pluginId';\nimport * as parser from 'uri-template';\nimport { EntitiesBatchResponse } from '../models/EntitiesBatchResponse.model';\nimport { EntitiesQueryResponse } from '../models/EntitiesQueryResponse.model';\nimport { Entity } from '../models/Entity.model';\nimport { EntityAncestryResponse } from '../models/EntityAncestryResponse.model';\nimport { EntityFacetsResponse } from '../models/EntityFacetsResponse.model';\nimport { GetEntitiesByRefsRequest } from '../models/GetEntitiesByRefsRequest.model';\nimport { RefreshEntityRequest } from '../models/RefreshEntityRequest.model';\nimport { ValidateEntityRequest } from '../models/ValidateEntityRequest.model';\nimport { AnalyzeLocationRequest } from '../models/AnalyzeLocationRequest.model';\nimport { AnalyzeLocationResponse } from '../models/AnalyzeLocationResponse.model';\nimport { CreateLocation201Response } from '../models/CreateLocation201Response.model';\nimport { CreateLocationRequest } from '../models/CreateLocationRequest.model';\nimport { GetLocations200ResponseInner } from '../models/GetLocations200ResponseInner.model';\nimport { Location } from '../models/Location.model';\n\n/**\n * Wraps the Response type to convey a type on the json call.\n *\n * @public\n */\nexport type TypedResponse<T> = Omit<Response, 'json'> & {\n  json: () => Promise<T>;\n};\n\n/**\n * Options you can pass into a request for additional information.\n *\n * @public\n */\nexport interface RequestOptions {\n  token?: string;\n}\n/**\n * @public\n */\nexport type DeleteEntityByUid = {\n  path: {\n    uid: string;\n  };\n};\n/**\n * @public\n */\nexport type GetEntities = {\n  query: {\n    fields?: Array<string>;\n    limit?: number;\n    filter?: Array<string>;\n    offset?: number;\n    after?: string;\n    order?: Array<string>;\n  };\n};\n/**\n * @public\n */\nexport type GetEntitiesByQuery = {\n  query: {\n    fields?: Array<string>;\n    limit?: number;\n    offset?: number;\n    orderField?: Array<string>;\n    cursor?: string;\n    filter?: Array<string>;\n    fullTextFilterTerm?: string;\n    fullTextFilterFields?: Array<string>;\n  };\n};\n/**\n * @public\n */\nexport type GetEntitiesByRefs = {\n  body: GetEntitiesByRefsRequest;\n  query: {\n    filter?: Array<string>;\n  };\n};\n/**\n * @public\n */\nexport type GetEntityAncestryByName = {\n  path: {\n    kind: string;\n    namespace: string;\n    name: string;\n  };\n};\n/**\n * @public\n */\nexport type GetEntityByName = {\n  path: {\n    kind: string;\n    namespace: string;\n    name: string;\n  };\n};\n/**\n * @public\n */\nexport type GetEntityByUid = {\n  path: {\n    uid: string;\n  };\n};\n/**\n * @public\n */\nexport type GetEntityFacets = {\n  query: {\n    facet: Array<string>;\n    filter?: Array<string>;\n  };\n};\n/**\n * @public\n */\nexport type RefreshEntity = {\n  body: RefreshEntityRequest;\n};\n/**\n * @public\n */\nexport type ValidateEntity = {\n  body: ValidateEntityRequest;\n};\n/**\n * @public\n */\nexport type AnalyzeLocation = {\n  body: AnalyzeLocationRequest;\n};\n/**\n * @public\n */\nexport type CreateLocation = {\n  body: CreateLocationRequest;\n  query: {\n    dryRun?: string;\n  };\n};\n/**\n * @public\n */\nexport type DeleteLocation = {\n  path: {\n    id: string;\n  };\n};\n/**\n * @public\n */\nexport type GetLocation = {\n  path: {\n    id: string;\n  };\n};\n/**\n * @public\n */\nexport type GetLocationByEntity = {\n  path: {\n    kind: string;\n    namespace: string;\n    name: string;\n  };\n};\n/**\n * @public\n */\nexport type GetLocations = {};\n\n/**\n * @public\n */\nexport class DefaultApiClient {\n  private readonly discoveryApi: DiscoveryApi;\n  private readonly fetchApi: FetchApi;\n\n  constructor(options: {\n    discoveryApi: { getBaseUrl(pluginId: string): Promise<string> };\n    fetchApi?: { fetch: typeof fetch };\n  }) {\n    this.discoveryApi = options.discoveryApi;\n    this.fetchApi = options.fetchApi || { fetch: crossFetch };\n  }\n\n  /**\n   * Delete a single entity by UID.\n   * @param uid -\n   */\n  public async deleteEntityByUid(\n    // @ts-ignore\n    request: DeleteEntityByUid,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<void>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-uid/{uid}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      uid: request.path.uid,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'DELETE',\n    });\n  }\n\n  /**\n     * Get all entities matching a given filter.\n     * @param fields - By default the full entities are returned, but you can pass in a &#x60;fields&#x60; query\nparameter which selects what parts of the entity data to retain. This makes the\nresponse smaller and faster to transfer, and may allow the catalog to perform\nmore efficient queries.\n\nThe query parameter value is a comma separated list of simplified JSON paths\nlike above. Each path corresponds to the key of either a value, or of a subtree\nroot that you want to keep in the output. The rest is pruned away. For example,\nspecifying &#x60;?fields&#x3D;metadata.name,metadata.annotations,spec&#x60; retains only the\n&#x60;name&#x60; and &#x60;annotations&#x60; fields of the &#x60;metadata&#x60; of each entity (it&#39;ll be an\nobject with at most two keys), keeps the entire &#x60;spec&#x60; unchanged, and cuts out\nall other roots such as &#x60;relations&#x60;.\n\nSome more real world usable examples:\n\n- Return only enough data to form the full ref of each entity:\n\n  &#x60;/entities/by-query?fields&#x3D;kind,metadata.namespace,metadata.name&#x60;\n\n     * @param limit - Number of records to return in the response.\n     * @param filter - You can pass in one or more filter sets that get matched against each entity.\nEach filter set is a number of conditions that all have to match for the\ncondition to be true (conditions effectively have an AND between them). At least\none filter set has to be true for the entity to be part of the result set\n(filter sets effectively have an OR between them).\n\nExample:\n\n&#x60;&#x60;&#x60;text\n/entities/by-query?filter&#x3D;kind&#x3D;user,metadata.namespace&#x3D;default&amp;filter&#x3D;kind&#x3D;group,spec.type\n\n  Return entities that match\n\n    Filter set 1:\n      Condition 1: kind &#x3D; user\n                  AND\n      Condition 2: metadata.namespace &#x3D; default\n\n    OR\n\n    Filter set 2:\n      Condition 1: kind &#x3D; group\n                  AND\n      Condition 2: spec.type exists\n&#x60;&#x60;&#x60;\n\nEach condition is either on the form &#x60;&lt;key&gt;&#x60;, or on the form &#x60;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;.\nThe first form asserts on the existence of a certain key (with any value), and\nthe second asserts that the key exists and has a certain value. All checks are\nalways case _insensitive_.\n\nIn all cases, the key is a simplified JSON path in a given piece of entity data.\nEach part of the path is a key of an object, and the traversal also descends\nthrough arrays. There are two special forms:\n\n- Array items that are simple value types (such as strings) match on a key-value\n  pair where the key is the item as a string, and the value is the string &#x60;true&#x60;\n- Relations can be matched on a &#x60;relations.&lt;type&gt;&#x3D;&lt;targetRef&gt;&#x60; form\n\nLet&#39;s look at a simplified example to illustrate the concept:\n\n&#x60;&#x60;&#x60;json\n{\n  &quot;a&quot;: {\n    &quot;b&quot;: [&quot;c&quot;, { &quot;d&quot;: 1 }],\n    &quot;e&quot;: 7\n  }\n}\n&#x60;&#x60;&#x60;\n\nThis would match any one of the following conditions:\n\n- &#x60;a&#x60;\n- &#x60;a.b&#x60;\n- &#x60;a.b.c&#x60;\n- &#x60;a.b.c&#x3D;true&#x60;\n- &#x60;a.b.d&#x60;\n- &#x60;a.b.d&#x3D;1&#x60;\n- &#x60;a.e&#x60;\n- &#x60;a.e&#x3D;7&#x60;\n\nSome more real world usable examples:\n\n- Return all orphaned entities:\n\n  &#x60;/entities/by-query?filter&#x3D;metadata.annotations.backstage.io/orphan&#x3D;true&#x60;\n\n- Return all users and groups:\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;user&amp;filter&#x3D;kind&#x3D;group&#x60;\n\n- Return all service components:\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;component,spec.type&#x3D;service&#x60;\n\n- Return all entities with the &#x60;java&#x60; tag:\n\n  &#x60;/entities/by-query?filter&#x3D;metadata.tags.java&#x60;\n\n- Return all users who are members of the &#x60;ops&#x60; group (note that the full\n  [reference](references.md) of the group is used):\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;user,relations.memberof&#x3D;group:default/ops&#x60;\n\n     * @param offset - Number of records to skip in the query page.\n     * @param after - Pointer to the previous page of results.\n     * @param order - \n     */\n  public async getEntities(\n    // @ts-ignore\n    request: GetEntities,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Array<Entity>>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities{?fields,limit,filter*,offset,after,order*}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      ...request.query,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n     * Search for entities by a given query.\n     * @param fields - By default the full entities are returned, but you can pass in a &#x60;fields&#x60; query\nparameter which selects what parts of the entity data to retain. This makes the\nresponse smaller and faster to transfer, and may allow the catalog to perform\nmore efficient queries.\n\nThe query parameter value is a comma separated list of simplified JSON paths\nlike above. Each path corresponds to the key of either a value, or of a subtree\nroot that you want to keep in the output. The rest is pruned away. For example,\nspecifying &#x60;?fields&#x3D;metadata.name,metadata.annotations,spec&#x60; retains only the\n&#x60;name&#x60; and &#x60;annotations&#x60; fields of the &#x60;metadata&#x60; of each entity (it&#39;ll be an\nobject with at most two keys), keeps the entire &#x60;spec&#x60; unchanged, and cuts out\nall other roots such as &#x60;relations&#x60;.\n\nSome more real world usable examples:\n\n- Return only enough data to form the full ref of each entity:\n\n  &#x60;/entities/by-query?fields&#x3D;kind,metadata.namespace,metadata.name&#x60;\n\n     * @param limit - Number of records to return in the response.\n     * @param offset - Number of records to skip in the query page.\n     * @param orderField - By default the entities are returned ordered by their internal uid. You can\ncustomize the &#x60;orderField&#x60; query parameters to affect that ordering.\n\nFor example, to return entities by their name:\n\n&#x60;/entities/by-query?orderField&#x3D;metadata.name,asc&#x60;\n\nEach parameter can be followed by &#x60;asc&#x60; for ascending lexicographical order or\n&#x60;desc&#x60; for descending (reverse) lexicographical order.\n\n     * @param cursor - You may pass the &#x60;cursor&#x60; query parameters to perform cursor based pagination\nthrough the set of entities. The value of &#x60;cursor&#x60; will be returned in the response, under the &#x60;pageInfo&#x60; property:\n\n&#x60;&#x60;&#x60;json\n  &quot;pageInfo&quot;: {\n    &quot;nextCursor&quot;: &quot;a-cursor&quot;,\n    &quot;prevCursor&quot;: &quot;another-cursor&quot;\n  }\n&#x60;&#x60;&#x60;\n\nIf &#x60;nextCursor&#x60; exists, it can be used to retrieve the next batch of entities. Following the same approach,\nif &#x60;prevCursor&#x60; exists, it can be used to retrieve the previous batch of entities.\n\n- [&#x60;filter&#x60;](#filtering), for selecting only a subset of all entities\n- [&#x60;fields&#x60;](#field-selection), for selecting only parts of the full data\n  structure of each entity\n- &#x60;limit&#x60; for limiting the number of entities returned (20 is the default)\n- [&#x60;orderField&#x60;](#ordering), for deciding the order of the entities\n- &#x60;fullTextFilter&#x60;\n  **NOTE**: [&#x60;filter&#x60;, &#x60;orderField&#x60;, &#x60;fullTextFilter&#x60;] and &#x60;cursor&#x60; are mutually exclusive. This means that,\n  it isn&#39;t possible to change any of [&#x60;filter&#x60;, &#x60;orderField&#x60;, &#x60;fullTextFilter&#x60;] when passing &#x60;cursor&#x60; as query parameters,\n  as changing any of these properties will affect pagination. If any of &#x60;filter&#x60;, &#x60;orderField&#x60;, &#x60;fullTextFilter&#x60; is specified together with &#x60;cursor&#x60;, only the latter is taken into consideration.\n\n     * @param filter - You can pass in one or more filter sets that get matched against each entity.\nEach filter set is a number of conditions that all have to match for the\ncondition to be true (conditions effectively have an AND between them). At least\none filter set has to be true for the entity to be part of the result set\n(filter sets effectively have an OR between them).\n\nExample:\n\n&#x60;&#x60;&#x60;text\n/entities/by-query?filter&#x3D;kind&#x3D;user,metadata.namespace&#x3D;default&amp;filter&#x3D;kind&#x3D;group,spec.type\n\n  Return entities that match\n\n    Filter set 1:\n      Condition 1: kind &#x3D; user\n                  AND\n      Condition 2: metadata.namespace &#x3D; default\n\n    OR\n\n    Filter set 2:\n      Condition 1: kind &#x3D; group\n                  AND\n      Condition 2: spec.type exists\n&#x60;&#x60;&#x60;\n\nEach condition is either on the form &#x60;&lt;key&gt;&#x60;, or on the form &#x60;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;.\nThe first form asserts on the existence of a certain key (with any value), and\nthe second asserts that the key exists and has a certain value. All checks are\nalways case _insensitive_.\n\nIn all cases, the key is a simplified JSON path in a given piece of entity data.\nEach part of the path is a key of an object, and the traversal also descends\nthrough arrays. There are two special forms:\n\n- Array items that are simple value types (such as strings) match on a key-value\n  pair where the key is the item as a string, and the value is the string &#x60;true&#x60;\n- Relations can be matched on a &#x60;relations.&lt;type&gt;&#x3D;&lt;targetRef&gt;&#x60; form\n\nLet&#39;s look at a simplified example to illustrate the concept:\n\n&#x60;&#x60;&#x60;json\n{\n  &quot;a&quot;: {\n    &quot;b&quot;: [&quot;c&quot;, { &quot;d&quot;: 1 }],\n    &quot;e&quot;: 7\n  }\n}\n&#x60;&#x60;&#x60;\n\nThis would match any one of the following conditions:\n\n- &#x60;a&#x60;\n- &#x60;a.b&#x60;\n- &#x60;a.b.c&#x60;\n- &#x60;a.b.c&#x3D;true&#x60;\n- &#x60;a.b.d&#x60;\n- &#x60;a.b.d&#x3D;1&#x60;\n- &#x60;a.e&#x60;\n- &#x60;a.e&#x3D;7&#x60;\n\nSome more real world usable examples:\n\n- Return all orphaned entities:\n\n  &#x60;/entities/by-query?filter&#x3D;metadata.annotations.backstage.io/orphan&#x3D;true&#x60;\n\n- Return all users and groups:\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;user&amp;filter&#x3D;kind&#x3D;group&#x60;\n\n- Return all service components:\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;component,spec.type&#x3D;service&#x60;\n\n- Return all entities with the &#x60;java&#x60; tag:\n\n  &#x60;/entities/by-query?filter&#x3D;metadata.tags.java&#x60;\n\n- Return all users who are members of the &#x60;ops&#x60; group (note that the full\n  [reference](references.md) of the group is used):\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;user,relations.memberof&#x3D;group:default/ops&#x60;\n\n     * @param fullTextFilterTerm - Text search term.\n     * @param fullTextFilterFields - A comma separated list of fields to sort returned results by.\n     */\n  public async getEntitiesByQuery(\n    // @ts-ignore\n    request: GetEntitiesByQuery,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<EntitiesQueryResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-query{?fields,limit,offset,orderField*,cursor,filter*,fullTextFilterTerm,fullTextFilterFields}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      ...request.query,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n     * Get a batch set of entities given an array of entityRefs.\n     * @param filter - You can pass in one or more filter sets that get matched against each entity.\nEach filter set is a number of conditions that all have to match for the\ncondition to be true (conditions effectively have an AND between them). At least\none filter set has to be true for the entity to be part of the result set\n(filter sets effectively have an OR between them).\n\nExample:\n\n&#x60;&#x60;&#x60;text\n/entities/by-query?filter&#x3D;kind&#x3D;user,metadata.namespace&#x3D;default&amp;filter&#x3D;kind&#x3D;group,spec.type\n\n  Return entities that match\n\n    Filter set 1:\n      Condition 1: kind &#x3D; user\n                  AND\n      Condition 2: metadata.namespace &#x3D; default\n\n    OR\n\n    Filter set 2:\n      Condition 1: kind &#x3D; group\n                  AND\n      Condition 2: spec.type exists\n&#x60;&#x60;&#x60;\n\nEach condition is either on the form &#x60;&lt;key&gt;&#x60;, or on the form &#x60;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;.\nThe first form asserts on the existence of a certain key (with any value), and\nthe second asserts that the key exists and has a certain value. All checks are\nalways case _insensitive_.\n\nIn all cases, the key is a simplified JSON path in a given piece of entity data.\nEach part of the path is a key of an object, and the traversal also descends\nthrough arrays. There are two special forms:\n\n- Array items that are simple value types (such as strings) match on a key-value\n  pair where the key is the item as a string, and the value is the string &#x60;true&#x60;\n- Relations can be matched on a &#x60;relations.&lt;type&gt;&#x3D;&lt;targetRef&gt;&#x60; form\n\nLet&#39;s look at a simplified example to illustrate the concept:\n\n&#x60;&#x60;&#x60;json\n{\n  &quot;a&quot;: {\n    &quot;b&quot;: [&quot;c&quot;, { &quot;d&quot;: 1 }],\n    &quot;e&quot;: 7\n  }\n}\n&#x60;&#x60;&#x60;\n\nThis would match any one of the following conditions:\n\n- &#x60;a&#x60;\n- &#x60;a.b&#x60;\n- &#x60;a.b.c&#x60;\n- &#x60;a.b.c&#x3D;true&#x60;\n- &#x60;a.b.d&#x60;\n- &#x60;a.b.d&#x3D;1&#x60;\n- &#x60;a.e&#x60;\n- &#x60;a.e&#x3D;7&#x60;\n\nSome more real world usable examples:\n\n- Return all orphaned entities:\n\n  &#x60;/entities/by-query?filter&#x3D;metadata.annotations.backstage.io/orphan&#x3D;true&#x60;\n\n- Return all users and groups:\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;user&amp;filter&#x3D;kind&#x3D;group&#x60;\n\n- Return all service components:\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;component,spec.type&#x3D;service&#x60;\n\n- Return all entities with the &#x60;java&#x60; tag:\n\n  &#x60;/entities/by-query?filter&#x3D;metadata.tags.java&#x60;\n\n- Return all users who are members of the &#x60;ops&#x60; group (note that the full\n  [reference](references.md) of the group is used):\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;user,relations.memberof&#x3D;group:default/ops&#x60;\n\n     * @param getEntitiesByRefsRequest - \n     */\n  public async getEntitiesByRefs(\n    // @ts-ignore\n    request: GetEntitiesByRefs,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<EntitiesBatchResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-refs{?filter*}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      ...request.query,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n\n  /**\n   * Get an entity's ancestry by entity ref.\n   * @param kind -\n   * @param namespace -\n   * @param name -\n   */\n  public async getEntityAncestryByName(\n    // @ts-ignore\n    request: GetEntityAncestryByName,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<EntityAncestryResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-name/{kind}/{namespace}/{name}/ancestry`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      kind: request.path.kind,\n      namespace: request.path.namespace,\n      name: request.path.name,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get an entity by an entity ref.\n   * @param kind -\n   * @param namespace -\n   * @param name -\n   */\n  public async getEntityByName(\n    // @ts-ignore\n    request: GetEntityByName,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Entity>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-name/{kind}/{namespace}/{name}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      kind: request.path.kind,\n      namespace: request.path.namespace,\n      name: request.path.name,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get a single entity by the UID.\n   * @param uid -\n   */\n  public async getEntityByUid(\n    // @ts-ignore\n    request: GetEntityByUid,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Entity>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-uid/{uid}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      uid: request.path.uid,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n     * Get all entity facets that match the given filters.\n     * @param facet - \n     * @param filter - You can pass in one or more filter sets that get matched against each entity.\nEach filter set is a number of conditions that all have to match for the\ncondition to be true (conditions effectively have an AND between them). At least\none filter set has to be true for the entity to be part of the result set\n(filter sets effectively have an OR between them).\n\nExample:\n\n&#x60;&#x60;&#x60;text\n/entities/by-query?filter&#x3D;kind&#x3D;user,metadata.namespace&#x3D;default&amp;filter&#x3D;kind&#x3D;group,spec.type\n\n  Return entities that match\n\n    Filter set 1:\n      Condition 1: kind &#x3D; user\n                  AND\n      Condition 2: metadata.namespace &#x3D; default\n\n    OR\n\n    Filter set 2:\n      Condition 1: kind &#x3D; group\n                  AND\n      Condition 2: spec.type exists\n&#x60;&#x60;&#x60;\n\nEach condition is either on the form &#x60;&lt;key&gt;&#x60;, or on the form &#x60;&lt;key&gt;&#x3D;&lt;value&gt;&#x60;.\nThe first form asserts on the existence of a certain key (with any value), and\nthe second asserts that the key exists and has a certain value. All checks are\nalways case _insensitive_.\n\nIn all cases, the key is a simplified JSON path in a given piece of entity data.\nEach part of the path is a key of an object, and the traversal also descends\nthrough arrays. There are two special forms:\n\n- Array items that are simple value types (such as strings) match on a key-value\n  pair where the key is the item as a string, and the value is the string &#x60;true&#x60;\n- Relations can be matched on a &#x60;relations.&lt;type&gt;&#x3D;&lt;targetRef&gt;&#x60; form\n\nLet&#39;s look at a simplified example to illustrate the concept:\n\n&#x60;&#x60;&#x60;json\n{\n  &quot;a&quot;: {\n    &quot;b&quot;: [&quot;c&quot;, { &quot;d&quot;: 1 }],\n    &quot;e&quot;: 7\n  }\n}\n&#x60;&#x60;&#x60;\n\nThis would match any one of the following conditions:\n\n- &#x60;a&#x60;\n- &#x60;a.b&#x60;\n- &#x60;a.b.c&#x60;\n- &#x60;a.b.c&#x3D;true&#x60;\n- &#x60;a.b.d&#x60;\n- &#x60;a.b.d&#x3D;1&#x60;\n- &#x60;a.e&#x60;\n- &#x60;a.e&#x3D;7&#x60;\n\nSome more real world usable examples:\n\n- Return all orphaned entities:\n\n  &#x60;/entities/by-query?filter&#x3D;metadata.annotations.backstage.io/orphan&#x3D;true&#x60;\n\n- Return all users and groups:\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;user&amp;filter&#x3D;kind&#x3D;group&#x60;\n\n- Return all service components:\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;component,spec.type&#x3D;service&#x60;\n\n- Return all entities with the &#x60;java&#x60; tag:\n\n  &#x60;/entities/by-query?filter&#x3D;metadata.tags.java&#x60;\n\n- Return all users who are members of the &#x60;ops&#x60; group (note that the full\n  [reference](references.md) of the group is used):\n\n  &#x60;/entities/by-query?filter&#x3D;kind&#x3D;user,relations.memberof&#x3D;group:default/ops&#x60;\n\n     */\n  public async getEntityFacets(\n    // @ts-ignore\n    request: GetEntityFacets,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<EntityFacetsResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entity-facets{?facet*,filter*}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      ...request.query,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Refresh the entity related to entityRef.\n   * @param refreshEntityRequest -\n   */\n  public async refreshEntity(\n    // @ts-ignore\n    request: RefreshEntity,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<void>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/refresh`;\n\n    const uri = parser.parse(uriTemplate).expand({});\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n\n  /**\n   * Validate that a passed in entity has no errors in schema.\n   * @param validateEntityRequest -\n   */\n  public async validateEntity(\n    // @ts-ignore\n    request: ValidateEntity,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<void>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/validate-entity`;\n\n    const uri = parser.parse(uriTemplate).expand({});\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n\n  /**\n   * Validate a given location.\n   * @param analyzeLocationRequest -\n   */\n  public async analyzeLocation(\n    // @ts-ignore\n    request: AnalyzeLocation,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<AnalyzeLocationResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/analyze-location`;\n\n    const uri = parser.parse(uriTemplate).expand({});\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n\n  /**\n   * Create a location for a given target.\n   * @param createLocationRequest -\n   * @param dryRun -\n   */\n  public async createLocation(\n    // @ts-ignore\n    request: CreateLocation,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<CreateLocation201Response>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/locations{?dryRun}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      ...request.query,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n\n  /**\n   * Delete a location by id.\n   * @param id -\n   */\n  public async deleteLocation(\n    // @ts-ignore\n    request: DeleteLocation,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<void>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/locations/{id}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      id: request.path.id,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'DELETE',\n    });\n  }\n\n  /**\n   * Get a location by id.\n   * @param id -\n   */\n  public async getLocation(\n    // @ts-ignore\n    request: GetLocation,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Location>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/locations/{id}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      id: request.path.id,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get a location for entity.\n   * @param kind -\n   * @param namespace -\n   * @param name -\n   */\n  public async getLocationByEntity(\n    // @ts-ignore\n    request: GetLocationByEntity,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Location>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/locations/by-entity/{kind}/{namespace}/{name}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      kind: request.path.kind,\n      namespace: request.path.namespace,\n      name: request.path.name,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get all locations\n   */\n  public async getLocations(\n    // @ts-ignore\n    request: GetLocations,\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Array<GetLocations200ResponseInner>>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/locations`;\n\n    const uri = parser.parse(uriTemplate).expand({});\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n}\n"],"names":["crossFetch","pluginId","parser"],"mappings":"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"}