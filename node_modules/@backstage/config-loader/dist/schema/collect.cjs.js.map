{"version":3,"file":"collect.cjs.js","sources":["../../src/schema/collect.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs-extra';\nimport { EOL } from 'os';\nimport {\n  resolve as resolvePath,\n  relative as relativePath,\n  dirname,\n  sep,\n} from 'path';\nimport { ConfigSchemaPackageEntry } from './types';\nimport { JsonObject } from '@backstage/types';\nimport { assertError } from '@backstage/errors';\n\ntype Item = {\n  name?: string;\n  parentPath?: string;\n  packagePath?: string;\n};\n\nconst req =\n  typeof __non_webpack_require__ === 'undefined'\n    ? require\n    : __non_webpack_require__;\n\n/**\n * This collects all known config schemas across all dependencies of the app.\n */\nexport async function collectConfigSchemas(\n  packageNames: string[],\n  packagePaths: string[],\n): Promise<ConfigSchemaPackageEntry[]> {\n  const schemas = new Array<ConfigSchemaPackageEntry>();\n  const tsSchemaPaths = new Array<{ packageName: string; path: string }>();\n  const visitedPackageVersions = new Map<string, Set<string>>(); // pkgName: [versions...]\n\n  const currentDir = await fs.realpath(process.cwd());\n\n  async function processItem(item: Item) {\n    let pkgPath = item.packagePath;\n\n    if (pkgPath) {\n      const pkgExists = await fs.pathExists(pkgPath);\n      if (!pkgExists) {\n        return;\n      }\n    } else if (item.name) {\n      const { name, parentPath } = item;\n\n      try {\n        pkgPath = req.resolve(\n          `${name}/package.json`,\n          parentPath && {\n            paths: [parentPath],\n          },\n        );\n      } catch {\n        // We can somewhat safely ignore packages that don't export package.json,\n        // as they are likely not part of the Backstage ecosystem anyway.\n      }\n    }\n    if (!pkgPath) {\n      return;\n    }\n\n    const pkg = await fs.readJson(pkgPath);\n\n    // Ensures that we only process the same version of each package once.\n    let versions = visitedPackageVersions.get(pkg.name);\n    if (versions?.has(pkg.version)) {\n      return;\n    }\n    if (!versions) {\n      versions = new Set();\n      visitedPackageVersions.set(pkg.name, versions);\n    }\n    versions.add(pkg.version);\n\n    const depNames = [\n      ...Object.keys(pkg.dependencies ?? {}),\n      ...Object.keys(pkg.devDependencies ?? {}),\n      ...Object.keys(pkg.optionalDependencies ?? {}),\n      ...Object.keys(pkg.peerDependencies ?? {}),\n    ];\n\n    // TODO(Rugvip): Trying this out to avoid having to traverse the full dependency graph,\n    //               since that's pretty slow. We probably need a better way to determine when\n    //               we've left the Backstage ecosystem, but this will do for now.\n    const hasSchema = 'configSchema' in pkg;\n    const hasBackstageDep = depNames.some(_ => _.startsWith('@backstage/'));\n    if (!hasSchema && !hasBackstageDep) {\n      return;\n    }\n    if (hasSchema) {\n      if (typeof pkg.configSchema === 'string') {\n        const isJson = pkg.configSchema.endsWith('.json');\n        const isDts = pkg.configSchema.endsWith('.d.ts');\n        if (!isJson && !isDts) {\n          throw new Error(\n            `Config schema files must be .json or .d.ts, got ${pkg.configSchema}`,\n          );\n        }\n        if (isDts) {\n          tsSchemaPaths.push({\n            path: relativePath(\n              currentDir,\n              resolvePath(dirname(pkgPath), pkg.configSchema),\n            ),\n            packageName: pkg.name,\n          });\n        } else {\n          const path = resolvePath(dirname(pkgPath), pkg.configSchema);\n          const value = await fs.readJson(path);\n          schemas.push({\n            packageName: pkg.name,\n            value,\n            path: relativePath(currentDir, path),\n          });\n        }\n      } else {\n        schemas.push({\n          packageName: pkg.name,\n          value: pkg.configSchema,\n          path: relativePath(currentDir, pkgPath),\n        });\n      }\n    }\n\n    await Promise.all(\n      depNames.map(depName =>\n        processItem({ name: depName, parentPath: pkgPath }),\n      ),\n    );\n  }\n\n  await Promise.all([\n    ...packageNames.map(name => processItem({ name, parentPath: currentDir })),\n    ...packagePaths.map(path => processItem({ name: path, packagePath: path })),\n  ]);\n\n  const tsSchemas = await compileTsSchemas(tsSchemaPaths);\n  const allSchemas = schemas.concat(tsSchemas);\n\n  const hasBackendDefaults = allSchemas.some(\n    ({ packageName }) => packageName === '@backstage/backend-defaults',\n  );\n\n  if (hasBackendDefaults) {\n    // We filter out backend-common schemas here to avoid issues with\n    // schema merging over different versions of the same schema.\n    // led to issues such as https://github.com/backstage/backstage/issues/28170\n    return allSchemas.filter(\n      ({ packageName }) => packageName !== '@backstage/backend-common',\n    );\n  }\n\n  return allSchemas;\n}\n\n// This handles the support of TypeScript .d.ts config schema declarations.\n// We collect all typescript schema definition and compile them all in one go.\n// This is much faster than compiling them separately.\nasync function compileTsSchemas(\n  entries: { path: string; packageName: string }[],\n) {\n  if (entries.length === 0) {\n    return [];\n  }\n\n  // Lazy loaded, because this brings up all of TypeScript and we don't\n  // want that eagerly loaded in tests\n  const { getProgramFromFiles, buildGenerator } =\n    require('typescript-json-schema') as typeof import('typescript-json-schema');\n\n  const program = getProgramFromFiles(\n    entries.map(({ path }) => path),\n    {\n      incremental: false,\n      isolatedModules: true,\n      lib: ['ES5'], // Skipping most libs speeds processing up a lot, we just need the primitive types anyway\n      noEmit: true,\n      noResolve: true,\n      skipLibCheck: true, // Skipping lib checks speeds things up\n      skipDefaultLibCheck: true,\n      strict: true,\n      typeRoots: [], // Do not include any additional types\n      types: [],\n    },\n  );\n\n  const tsSchemas = entries.map(({ path, packageName }) => {\n    let value;\n    try {\n      const generator = buildGenerator(\n        program,\n        // This enables the use of these tags in TSDoc comments\n        {\n          required: true,\n          validationKeywords: ['visibility', 'deepVisibility', 'deprecated'],\n        },\n        [path.split(sep).join('/')], // Unix paths are expected for all OSes here\n      );\n\n      // All schemas should export a `Config` symbol\n      value = generator?.getSchemaForSymbol('Config') as JsonObject | null;\n\n      // This makes sure that no additional symbols are defined in the schema. We don't allow\n      // this because they share a global namespace and will be merged together, leading to\n      // unpredictable behavior.\n      const userSymbols = new Set(generator?.getUserSymbols());\n      userSymbols.delete('Config');\n      if (userSymbols.size !== 0) {\n        const names = Array.from(userSymbols).join(\"', '\");\n        throw new Error(\n          `Invalid configuration schema in ${path}, additional symbol definitions are not allowed, found '${names}'`,\n        );\n      }\n\n      // This makes sure that no unsupported types are used in the schema, for example `Record<,>`.\n      // The generator will extract these as a schema reference, which will in turn be broken for our usage.\n      const reffedDefs = Object.keys(generator?.ReffedDefinitions ?? {});\n      if (reffedDefs.length !== 0) {\n        const lines = reffedDefs.join(`${EOL}  `);\n        throw new Error(\n          `Invalid configuration schema in ${path}, the following definitions are not supported:${EOL}${EOL}  ${lines}`,\n        );\n      }\n    } catch (error) {\n      assertError(error);\n      if (error.message !== 'type Config not found') {\n        throw error;\n      }\n    }\n\n    if (!value) {\n      throw new Error(`Invalid schema in ${path}, missing Config export`);\n    }\n    return { path, value, packageName };\n  });\n\n  return tsSchemas;\n}\n"],"names":["fs","relativePath","resolvePath","dirname","path","sep","EOL","assertError"],"mappings":"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"}