function extractProps(props, propDefs) {
  let className = (props.className || "").split(" ");
  let style = { ...props.style };
  for (const key in propDefs) {
    const propDef = propDefs[key];
    if (!Object.hasOwn(props, key) && !propDef.hasOwnProperty("default")) {
      continue;
    }
    const value = Object.hasOwn(props, key) ? props[key] : propDefs[key].default;
    const propDefsValues = propDef.values;
    const propDefsCustomProperties = propDef.customProperties;
    const propDefsClassName = propDef.className;
    const isResponsive = propDef.responsive;
    const handleValue = (val, prefix = "") => {
      if (key === "as") return;
      if (propDefsValues?.includes(val)) {
        className.push(`${prefix}${propDefsClassName}-${val}`);
      } else {
        if (propDefsCustomProperties) {
          for (const customProperty of propDefsCustomProperties) {
            const customPropertyKey = isResponsive && prefix ? `${customProperty}-${prefix.slice(0, -1)}` : customProperty;
            style[customPropertyKey] = val;
          }
        }
        className.push(`${prefix}${propDefsClassName}`);
      }
    };
    if (isResponsive && typeof value === "object" && value !== null) {
      const breakpointValues = value;
      for (const breakpoint in breakpointValues) {
        const prefix = breakpoint === "initial" ? "" : `${breakpoint}:`;
        handleValue(breakpointValues[breakpoint], prefix);
      }
    } else {
      handleValue(value);
    }
  }
  const cleanedProps = Object.keys(props).reduce((acc, key) => {
    if (!propDefs.hasOwnProperty(key)) {
      acc[key] = props[key];
    }
    return acc;
  }, {});
  const newClassNames = className.filter((name) => name && name.trim() !== "").join(" ");
  return { ...cleanedProps, className: newClassNames, style };
}

export { extractProps };
//# sourceMappingURL=extractProps.esm.js.map
