import * as react_jsx_runtime from 'react/jsx-runtime';
import * as react from 'react';
import { ReactNode, JSX as JSX$1, ComponentType, PropsWithChildren } from 'react';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { ApiHolder, ConfigApi, ApiRef, AnyApiFactory, IconComponent as IconComponent$1, SignInPageProps, AppTheme } from '@backstage/core-plugin-api';
export { AlertApi, AlertMessage, AnyApiFactory, AnyApiRef, ApiFactory, ApiHolder, ApiRef, ApiRefConfig, AppTheme, AppThemeApi, AuthProviderInfo, AuthRequestOptions, BackstageIdentityApi, BackstageIdentityResponse, BackstageUserIdentity, ConfigApi, DiscoveryApi, ErrorApi, ErrorApiError, ErrorApiErrorContext, FeatureFlag, FeatureFlagState, FeatureFlagsApi, FeatureFlagsSaveOptions, FetchApi, IdentityApi, OAuthApi, OAuthRequestApi, OAuthRequester, OAuthRequesterOptions, OAuthScope, OpenIdConnectApi, PendingOAuthRequest, ProfileInfo, ProfileInfoApi, SessionApi, SessionState, StorageApi, StorageValueSnapshot, TypesToApiRefs, alertApiRef, appThemeApiRef, atlassianAuthApiRef, bitbucketAuthApiRef, bitbucketServerAuthApiRef, configApiRef, createApiFactory, createApiRef, discoveryApiRef, errorApiRef, featureFlagsApiRef, fetchApiRef, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauthRequestApiRef, oktaAuthApiRef, oneloginAuthApiRef, storageApiRef, useApi, useApiHolder, vmwareCloudAuthApiRef, withApis } from '@backstage/core-plugin-api';
import { Expand, JsonObject } from '@backstage/types';
import { z } from 'zod';
import { TranslationResource, TranslationMessages } from '@backstage/core-plugin-api/alpha';
export { TranslationMessages, TranslationMessagesOptions, TranslationRef, TranslationRefOptions, TranslationResource, TranslationResourceOptions, createTranslationMessages, createTranslationRef, createTranslationResource, useTranslationRef } from '@backstage/core-plugin-api/alpha';
import * as _backstage_frontend_plugin_api from '@backstage/frontend-plugin-api';

/**
 * Common analytics context attributes.
 *
 * @public
 */
type CommonAnalyticsContext = {
    /**
     * The nearest known parent plugin where the event was captured.
     */
    pluginId: string;
    /**
     * The nearest known parent extension where the event was captured.
     */
    extensionId: string;
};
/**
 * Analytics context envelope.
 *
 * @public
 */
type AnalyticsContextValue = CommonAnalyticsContext & {
    [param in string]: string | boolean | number | undefined;
};

/**
 * Provides components in the child react tree an Analytics Context, ensuring
 * all analytics events captured within the context have relevant attributes.
 *
 * @remarks
 *
 * Analytics contexts are additive, meaning the context ultimately emitted with
 * an event is the combination of all contexts in the parent tree.
 *
 * @public
 */
declare const AnalyticsContext: (options: {
    attributes: Partial<AnalyticsContextValue>;
    children: ReactNode;
}) => react_jsx_runtime.JSX.Element;

/** @public */
type ExtensionDataValue<TData, TId extends string> = {
    readonly $$type: '@backstage/ExtensionDataValue';
    readonly id: TId;
    readonly value: TData;
};
/** @public */
type ExtensionDataRef<TData, TId extends string = string, TConfig extends {
    optional?: true;
} = {}> = {
    readonly $$type: '@backstage/ExtensionDataRef';
    readonly id: TId;
    readonly T: TData;
    readonly config: TConfig;
};
/** @public */
type ExtensionDataRefToValue<TDataRef extends AnyExtensionDataRef> = TDataRef extends ExtensionDataRef<infer IData, infer IId, any> ? ExtensionDataValue<IData, IId> : never;
/** @public */
type AnyExtensionDataRef = ExtensionDataRef<unknown, string, {
    optional?: true;
}>;
/** @public */
interface ConfigurableExtensionDataRef<TData, TId extends string, TConfig extends {
    optional?: true;
} = {}> extends ExtensionDataRef<TData, TId, TConfig> {
    optional(): ConfigurableExtensionDataRef<TData, TId, TConfig & {
        optional: true;
    }>;
    (t: TData): ExtensionDataValue<TData, TId>;
}
/** @public */
declare function createExtensionDataRef<TData>(): {
    with<TId extends string>(options: {
        id: TId;
    }): ConfigurableExtensionDataRef<TData, TId>;
};

/**
 * Catch-all type for route params.
 *
 * @public
 */
type AnyRouteRefParams = {
    [param in string]: string;
} | undefined;

/**
 * Absolute route reference.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface RouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/RouteRef';
    readonly T: TParams;
}
/**
 * Create a {@link RouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TParamKeys extends string = string>(config?: {
    /** A list of parameter names that the path that this route ref is bound to must contain */
    readonly params: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
}): RouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}>;

/** @public */
declare const coreExtensionData: {
    reactElement: ConfigurableExtensionDataRef<JSX$1.Element, "core.reactElement", {}>;
    routePath: ConfigurableExtensionDataRef<string, "core.routing.path", {}>;
    routeRef: ConfigurableExtensionDataRef<RouteRef<_backstage_frontend_plugin_api.AnyRouteRefParams>, "core.routing.ref", {}>;
};

/** @public */
interface ExtensionInput<UExtensionData extends ExtensionDataRef<unknown, string, {
    optional?: true;
}>, TConfig extends {
    singleton: boolean;
    optional: boolean;
}> {
    $$type: '@backstage/ExtensionInput';
    extensionData: Array<UExtensionData>;
    config: TConfig;
    replaces?: Array<{
        id: string;
        input: string;
    }>;
}
/** @public */
declare function createExtensionInput<UExtensionData extends ExtensionDataRef<unknown, string, {
    optional?: true;
}>, TConfig extends {
    singleton?: boolean;
    optional?: boolean;
}>(extensionData: Array<UExtensionData>, config?: TConfig & {
    replaces?: Array<{
        id: string;
        input: string;
    }>;
}): ExtensionInput<UExtensionData, {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
}>;

/** @public */
type ResolveInputValueOverrides<TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
} = {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}> = Expand<{
    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<any, {
        optional: infer IOptional extends boolean;
        singleton: boolean;
    }> ? IOptional extends true ? never : KName : never]: TInputs[KName] extends ExtensionInput<infer IDataRefs, {
        optional: boolean;
        singleton: infer ISingleton extends boolean;
    }> ? ISingleton extends true ? Iterable<ExtensionDataRefToValue<IDataRefs>> : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>> : never;
} & {
    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<any, {
        optional: infer IOptional extends boolean;
        singleton: boolean;
    }> ? IOptional extends true ? KName : never : never]?: TInputs[KName] extends ExtensionInput<infer IDataRefs, {
        optional: boolean;
        singleton: infer ISingleton extends boolean;
    }> ? ISingleton extends true ? Iterable<ExtensionDataRefToValue<IDataRefs>> : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>> : never;
}>;

/**
 * Descriptor of a route relative to an absolute {@link RouteRef}.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface SubRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/SubRouteRef';
    readonly T: TParams;
    readonly path: string;
}
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}` ? ParamPart<Part> | ParamNames<Rest> : ParamPart<S>;
/**
 * This utility type helps us infer a Param object type from a string path
 * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`
 * @ignore
 */
type PathParams<S extends string> = {
    [name in ParamNames<S>]: string;
};
/**
 * Merges a param object type with an optional params type into a params object.
 * @ignore
 */
type MergeParams<P1 extends {
    [param in string]: string;
}, P2 extends AnyRouteRefParams> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);
/**
 * Convert empty params to undefined.
 * @ignore
 */
type TrimEmptyParams<Params extends {
    [param in string]: string;
}> = keyof Params extends never ? undefined : Params;
/**
 * Creates a SubRouteRef type given the desired parameters and parent route parameters.
 * The parameters types are merged together while ensuring that there is no overlap between the two.
 *
 * @ignore
 */
type MakeSubRouteRef<Params extends {
    [param in string]: string;
}, ParentParams extends AnyRouteRefParams> = keyof Params & keyof ParentParams extends never ? SubRouteRef<TrimEmptyParams<MergeParams<Params, ParentParams>>> : never;
/**
 * Create a {@link SubRouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createSubRouteRef<Path extends string, ParentParams extends AnyRouteRefParams = never>(config: {
    path: Path;
    parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

/**
 * Route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface ExternalRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/ExternalRouteRef';
    readonly T: TParams;
}
/**
 * Creates a route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @param options - Description of the route reference to be created.
 * @public
 */
declare function createExternalRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TParamKeys extends string = string>(options?: {
    /**
     * The parameters that will be provided to the external route reference.
     */
    readonly params?: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
    /**
     * The route (typically in another plugin) that this should map to by default.
     *
     * The string is expected to be on the standard `<plugin id>.<route id>` form,
     * for example `techdocs.docRoot`.
     */
    defaultTarget?: string;
}): ExternalRouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}>;

/**
 * React hook for constructing URLs to routes.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}
 *
 * @param routeRef - The ref to route that should be converted to URL.
 * @returns A function that will in turn return the concrete URL of the `routeRef`, or `undefined` if the route is not available.
 * @public
 */
declare function useRouteRef<TParams extends AnyRouteRefParams>(routeRef: RouteRef<TParams> | SubRouteRef<TParams> | ExternalRouteRef<TParams>): RouteFunc<TParams> | undefined;

/**
 * React hook for retrieving dynamic params from the current URL.
 * @param _routeRef - Ref of the current route.
 * @public
 */
declare function useRouteRefParams<Params extends AnyRouteRefParams>(_routeRef: RouteRef<Params> | SubRouteRef<Params>): Params;

/** @public */
interface CreateFrontendModuleOptions<TPluginId extends string, TExtensions extends readonly ExtensionDefinition[]> {
    pluginId: TPluginId;
    extensions?: TExtensions;
    featureFlags?: FeatureFlagConfig[];
}
/** @public */
interface FrontendModule {
    readonly $$type: '@backstage/FrontendModule';
    readonly pluginId: string;
}
/** @public */
declare function createFrontendModule<TId extends string, TExtensions extends readonly ExtensionDefinition[] = []>(options: CreateFrontendModuleOptions<TId, TExtensions>): FrontendModule;

/** @public */
type PortableSchema<TOutput, TInput = TOutput> = {
    parse: (input: TInput) => TOutput;
    schema: JsonObject;
};

/** @public */
interface Extension<TConfig, TConfigInput = TConfig> {
    $$type: '@backstage/Extension';
    readonly id: string;
    readonly attachTo: ExtensionAttachToSpec;
    readonly disabled: boolean;
    readonly configSchema?: PortableSchema<TConfig, TConfigInput>;
}
/** @ignore */
type ResolveExtensionId<TExtension extends ExtensionDefinition, TNamespace extends string> = TExtension extends ExtensionDefinition<{
    kind: infer IKind extends string | undefined;
    name: infer IName extends string | undefined;
}> ? [string] extends [IKind | IName] ? never : (undefined extends IName ? TNamespace : `${TNamespace}/${IName}`) extends infer INamePart extends string ? IKind extends string ? `${IKind}:${INamePart}` : INamePart : never : never;

type CompareChars<A extends string, B extends string> = [A, B] extends [
    `${infer IAHead}${infer IARest}`,
    `${infer IBHead}${infer IBRest}`
] ? IAHead extends IBHead ? IBRest extends '' ? IARest extends '' ? 'eq' : 'gt' : IARest extends '' ? 'lt' : CompareChars<IARest, IBRest> : `0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz` extends `${string}${IAHead}${string}${IBHead}${string}` ? 'lt' : 'gt' : 'eq';
type CompareStrings<A extends string | undefined, B extends string | undefined> = A extends B ? 'eq' : A extends undefined ? 'lt' : B extends undefined ? 'gt' : CompareChars<A & string, B & string>;
type CompareExtensions<A extends ExtensionDefinition, B extends ExtensionDefinition> = CompareStrings<A['T']['kind'], B['T']['kind']> extends 'eq' ? CompareStrings<A['T']['name'], B['T']['name']> : CompareStrings<A['T']['kind'], B['T']['kind']>;
type SortExtensionsInner<TPivot extends ExtensionDefinition, TRest extends readonly ExtensionDefinition[], TLow extends readonly ExtensionDefinition[], THigh extends readonly ExtensionDefinition[]> = TRest extends [
    infer IHead extends ExtensionDefinition,
    ...infer IRest extends readonly ExtensionDefinition[]
] ? CompareExtensions<IHead, TPivot> extends 'lt' ? SortExtensionsInner<TPivot, IRest, [...TLow, IHead], THigh> : SortExtensionsInner<TPivot, IRest, TLow, [...THigh, IHead]> : [low: TLow, high: THigh];
type SortExtensions<T extends readonly ExtensionDefinition[]> = T extends [
    infer IPivot extends ExtensionDefinition,
    ...infer IRest extends readonly ExtensionDefinition[]
] ? SortExtensionsInner<IPivot, IRest, [], []> extends [
    low: infer ILow extends readonly ExtensionDefinition[],
    high: infer IHigh extends readonly ExtensionDefinition[]
] ? [...SortExtensions<ILow>, IPivot, ...SortExtensions<IHigh>] : 'invalid SortExtensionsInner' : [];
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type PopUnion$1<U> = UnionToIntersection<U extends any ? () => U : never> extends () => infer R ? [next: R, rest: Exclude<U, R>] : undefined;
type UnionToArray<U, T = U, TResult extends T[] = []> = PopUnion$1<U> extends [
    next: infer INext extends T,
    rest: infer IRest extends T
] ? UnionToArray<IRest, T, [INext, ...TResult]> : TResult;
type ExtensionArrayToMap<T extends ExtensionDefinition[], TId extends string, TOut extends {
    [KId in string]: ExtensionDefinition;
} = {}> = T extends [
    infer IHead extends ExtensionDefinition,
    ...infer IRest extends ExtensionDefinition[]
] ? ExtensionArrayToMap<IRest, TId, TOut & {
    [K in ResolveExtensionId<IHead, TId>]: IHead;
}> : TOut extends infer O ? {
    [K in keyof O]: O[K];
} : never;
/** @ignore */
type MakeSortedExtensionsMap<UExtensions extends ExtensionDefinition, TId extends string> = ExtensionArrayToMap<SortExtensions<UnionToArray<UExtensions>>, TId>;

/**
 * Information about the plugin.
 *
 * @public
 * @remarks
 *
 * This interface is intended to be extended via [module
 * augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation)
 * in order to add fields that are specific to each project.
 *
 * For example, one might add a `slackChannel` field that is read from the
 * opaque manifest file.
 *
 * See the options for `createApp` for more information about how to
 * customize the parsing of manifest files.
 */
interface FrontendPluginInfo {
    /**
     * The name of the package that implements the plugin.
     */
    packageName?: string;
    /**
     * The version of the plugin, typically the version of the package.json file.
     */
    version?: string;
    /**
     * As short description of the plugin, typically the description field in
     * package.json.
     */
    description?: string;
    /**
     * The owner entity references of the plugin.
     */
    ownerEntityRefs?: string[];
    /**
     * Links related to the plugin.
     */
    links?: Array<{
        title: string;
        url: string;
    }>;
}
/**
 * Options for providing information for a plugin.
 *
 * @public
 */
type FrontendPluginInfoOptions = {
    /**
     * A loader function for the package.json file for the plugin.
     */
    packageJson?: () => Promise<{
        name: string;
    } & JsonObject>;
    /**
     * A loader function for an opaque manifest file for the plugin.
     */
    manifest?: () => Promise<JsonObject>;
};
/** @public */
interface FrontendPlugin<TRoutes extends AnyRoutes = AnyRoutes, TExternalRoutes extends AnyExternalRoutes = AnyExternalRoutes, TExtensionMap extends {
    [id in string]: ExtensionDefinition;
} = {
    [id in string]: ExtensionDefinition;
}> {
    readonly $$type: '@backstage/FrontendPlugin';
    readonly id: string;
    readonly routes: TRoutes;
    readonly externalRoutes: TExternalRoutes;
    /**
     * Loads the plugin info.
     */
    info(): Promise<FrontendPluginInfo>;
    getExtension<TId extends keyof TExtensionMap>(id: TId): TExtensionMap[TId];
    withOverrides(options: {
        extensions: Array<ExtensionDefinition>;
        /**
         * Overrides the original info loaders of the plugin one by one.
         */
        info?: FrontendPluginInfoOptions;
    }): FrontendPlugin<TRoutes, TExternalRoutes, TExtensionMap>;
}
/** @public */
interface PluginOptions<TId extends string, TRoutes extends AnyRoutes, TExternalRoutes extends AnyExternalRoutes, TExtensions extends readonly ExtensionDefinition[]> {
    pluginId: TId;
    routes?: TRoutes;
    externalRoutes?: TExternalRoutes;
    extensions?: TExtensions;
    featureFlags?: FeatureFlagConfig[];
    info?: FrontendPluginInfoOptions;
}
/** @public */
declare function createFrontendPlugin<TId extends string, TRoutes extends AnyRoutes = {}, TExternalRoutes extends AnyExternalRoutes = {}, TExtensions extends readonly ExtensionDefinition[] = []>(options: PluginOptions<TId, TRoutes, TExternalRoutes, TExtensions>): FrontendPlugin<TRoutes, TExternalRoutes, MakeSortedExtensionsMap<TExtensions[number], TId>>;
/**
 * @public
 * @deprecated The `id` option is deprecated, use `pluginId` instead.
 */
declare function createFrontendPlugin<TId extends string, TRoutes extends AnyRoutes = {}, TExternalRoutes extends AnyExternalRoutes = {}, TExtensions extends readonly ExtensionDefinition[] = []>(options: Omit<PluginOptions<TId, TRoutes, TExternalRoutes, TExtensions>, 'pluginId'> & {
    id: string;
}): FrontendPlugin<TRoutes, TExternalRoutes, MakeSortedExtensionsMap<TExtensions[number], TId>>;

/**
 * Feature flag configuration.
 *
 * @public
 */
type FeatureFlagConfig = {
    /** Feature flag name */
    name: string;
};
/** @public */
type AnyRoutes = {
    [name in string]: RouteRef | SubRouteRef;
};
/** @public */
type AnyExternalRoutes = {
    [name in string]: ExternalRouteRef;
};
/** @public */
type ExtensionDataContainer<UExtensionData extends AnyExtensionDataRef> = Iterable<UExtensionData extends ExtensionDataRef<infer IData, infer IId, infer IConfig> ? IConfig['optional'] extends true ? never : ExtensionDataValue<IData, IId> : never> & {
    get<TId extends UExtensionData['id']>(ref: ExtensionDataRef<any, TId, any>): UExtensionData extends ExtensionDataRef<infer IData, TId, infer IConfig> ? IConfig['optional'] extends true ? IData | undefined : IData : never;
};
/** @public */
type ExtensionFactoryMiddleware = (originalFactory: (contextOverrides?: {
    config?: JsonObject;
}) => ExtensionDataContainer<AnyExtensionDataRef>, context: {
    node: AppNode;
    apis: ApiHolder;
    config?: JsonObject;
}) => Iterable<ExtensionDataValue<any, any>>;
/** @public  */
type FrontendFeature = FrontendPlugin | FrontendModule;

/**
 * Convert a single extension input into a matching resolved input.
 * @public
 */
type ResolvedExtensionInput<TExtensionInput extends ExtensionInput<any, any>> = TExtensionInput['extensionData'] extends Array<AnyExtensionDataRef> ? {
    node: AppNode;
} & ExtensionDataContainer<TExtensionInput['extensionData'][number]> : never;
/**
 * Converts an extension input map into a matching collection of resolved inputs.
 * @public
 */
type ResolvedExtensionInputs<TInputs extends {
    [name in string]: ExtensionInput<any, any>;
}> = {
    [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton'] ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]>>> : false extends TInputs[InputName]['config']['optional'] ? Expand<ResolvedExtensionInput<TInputs[InputName]>> : Expand<ResolvedExtensionInput<TInputs[InputName]> | undefined>;
};
type ToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type PopUnion<U> = ToIntersection<U extends any ? () => U : never> extends () => infer R ? [rest: Exclude<U, R>, next: R] : undefined;
/** @ignore */
type JoinStringUnion<U, TDiv extends string = ', ', TResult extends string = ''> = PopUnion<U> extends [infer IRest extends string, infer INext extends string] ? TResult extends '' ? JoinStringUnion<IRest, TDiv, INext> : JoinStringUnion<IRest, TDiv, `${TResult}${TDiv}${INext}`> : TResult;
/** @ignore */
type VerifyExtensionFactoryOutput<UDeclaredOutput extends AnyExtensionDataRef, UFactoryOutput extends ExtensionDataValue<any, any>> = (UDeclaredOutput extends any ? UDeclaredOutput['config']['optional'] extends true ? never : UDeclaredOutput['id'] : never) extends infer IRequiredOutputIds ? [IRequiredOutputIds] extends [UFactoryOutput['id']] ? [UFactoryOutput['id']] extends [UDeclaredOutput['id']] ? {} : `Error: The extension factory has undeclared output(s): ${JoinStringUnion<Exclude<UFactoryOutput['id'], UDeclaredOutput['id']>>}` : `Error: The extension factory is missing the following output(s): ${JoinStringUnion<Exclude<IRequiredOutputIds, UFactoryOutput['id']>>}` : never;
/** @public */
type ExtensionAttachToSpec = {
    id: string;
    input: string;
} | Array<{
    id: string;
    input: string;
}>;
/** @public */
type CreateExtensionOptions<TKind extends string | undefined, TName extends string | undefined, UOutput extends AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>> = {
    kind?: TKind;
    name?: TName;
    attachTo: ExtensionAttachToSpec;
    disabled?: boolean;
    inputs?: TInputs;
    output: Array<UOutput>;
    config?: {
        schema: TConfigSchema;
    };
    factory(context: {
        node: AppNode;
        apis: ApiHolder;
        config: {
            [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
        };
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }): Iterable<UFactoryOutput>;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;
/** @public */
type ExtensionDefinitionParameters = {
    kind?: string;
    name?: string;
    configInput?: {
        [K in string]: any;
    };
    config?: {
        [K in string]: any;
    };
    output?: AnyExtensionDataRef;
    inputs?: {
        [KName in string]: ExtensionInput<AnyExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    };
    params?: object;
};
/** @public */
type ExtensionDefinition<T extends ExtensionDefinitionParameters = ExtensionDefinitionParameters> = {
    $$type: '@backstage/ExtensionDefinition';
    readonly T: T;
    override<TExtensionConfigSchema extends {
        [key in string]: (zImpl: typeof z) => z.ZodType;
    }, UFactoryOutput extends ExtensionDataValue<any, any>, UNewOutput extends AnyExtensionDataRef, TExtraInputs extends {
        [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    }>(args: Expand<{
        attachTo?: ExtensionAttachToSpec;
        disabled?: boolean;
        inputs?: TExtraInputs & {
            [KName in keyof T['inputs']]?: `Error: Input '${KName & string}' is already defined in parent definition`;
        };
        output?: Array<UNewOutput>;
        config?: {
            schema: TExtensionConfigSchema & {
                [KName in keyof T['config']]?: `Error: Config key '${KName & string}' is already defined in parent schema`;
            };
        };
        factory?(originalFactory: (context?: Expand<{
            config?: T['config'];
            inputs?: ResolveInputValueOverrides<NonNullable<T['inputs']>>;
        } & ([T['params']] extends [never] ? {} : {
            params?: Partial<T['params']>;
        })>) => ExtensionDataContainer<NonNullable<T['output']>>, context: {
            node: AppNode;
            apis: ApiHolder;
            config: T['config'] & {
                [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
            };
            inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;
        }): Iterable<UFactoryOutput>;
    } & ([T['params']] extends [never] ? {} : {
        params?: Partial<T['params']>;
    })> & VerifyExtensionFactoryOutput<AnyExtensionDataRef extends UNewOutput ? NonNullable<T['output']> : UNewOutput, UFactoryOutput>): ExtensionDefinition<{
        kind: T['kind'];
        name: T['name'];
        output: AnyExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;
        inputs: T['inputs'] & TExtraInputs;
        config: T['config'] & {
            [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
        };
        configInput: T['configInput'] & z.input<z.ZodObject<{
            [key in keyof TExtensionConfigSchema]: ReturnType<TExtensionConfigSchema[key]>;
        }>>;
    }>;
};
/** @public */
declare function createExtension<UOutput extends AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>, const TKind extends string | undefined = undefined, const TName extends string | undefined = undefined>(options: CreateExtensionOptions<TKind, TName, UOutput, TInputs, TConfigSchema, UFactoryOutput>): ExtensionDefinition<{
    config: string extends keyof TConfigSchema ? {} : {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
    };
    configInput: string extends keyof TConfigSchema ? {} : z.input<z.ZodObject<{
        [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
    }>>;
    output: UOutput;
    inputs: TInputs;
    params: never;
    kind: string | undefined extends TKind ? undefined : TKind;
    name: string | undefined extends TName ? undefined : TName;
}>;

/** @public */
interface CreateFrontendFeatureLoaderOptions {
    loader(deps: {
        config: ConfigApi;
    }): Iterable<FrontendFeature | FrontendFeatureLoader | Promise<{
        default: FrontendFeature | FrontendFeatureLoader;
    }>> | Promise<Iterable<FrontendFeature | FrontendFeatureLoader | Promise<{
        default: FrontendFeature | FrontendFeatureLoader;
    }>>> | AsyncIterable<FrontendFeature | FrontendFeatureLoader | {
        default: FrontendFeature | FrontendFeatureLoader;
    }>;
}
/** @public */
interface FrontendFeatureLoader {
    readonly $$type: '@backstage/FrontendFeatureLoader';
}
/** @public */
declare function createFrontendFeatureLoader(options: CreateFrontendFeatureLoaderOptions): FrontendFeatureLoader;

/**
 * @public
 */
type CreateExtensionBlueprintOptions<TKind extends string, TName extends string | undefined, TParams, UOutput extends AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>, TDataRefs extends {
    [name in string]: AnyExtensionDataRef;
}> = {
    kind: TKind;
    attachTo: ExtensionAttachToSpec;
    disabled?: boolean;
    inputs?: TInputs;
    output: Array<UOutput>;
    name?: TName;
    config?: {
        schema: TConfigSchema;
    };
    factory(params: TParams, context: {
        node: AppNode;
        apis: ApiHolder;
        config: {
            [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
        };
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }): Iterable<UFactoryOutput>;
    dataRefs?: TDataRefs;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;
/** @public */
type ExtensionBlueprintParameters = {
    kind: string;
    name?: string;
    params?: object;
    configInput?: {
        [K in string]: any;
    };
    config?: {
        [K in string]: any;
    };
    output?: AnyExtensionDataRef;
    inputs?: {
        [KName in string]: ExtensionInput<AnyExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    };
    dataRefs?: {
        [name in string]: AnyExtensionDataRef;
    };
};
/**
 * @public
 */
interface ExtensionBlueprint<T extends ExtensionBlueprintParameters = ExtensionBlueprintParameters> {
    dataRefs: T['dataRefs'];
    make<TNewName extends string | undefined>(args: {
        name?: TNewName;
        attachTo?: ExtensionAttachToSpec;
        disabled?: boolean;
        params: T['params'];
    }): ExtensionDefinition<{
        kind: T['kind'];
        name: string | undefined extends TNewName ? T['name'] : TNewName;
        config: T['config'];
        configInput: T['configInput'];
        output: T['output'];
        inputs: T['inputs'];
        params: T['params'];
    }>;
    /**
     * Creates a new extension from the blueprint.
     *
     * You must either pass `params` directly, or define a `factory` that can
     * optionally call the original factory with the same params.
     */
    makeWithOverrides<TNewName extends string | undefined, TExtensionConfigSchema extends {
        [key in string]: (zImpl: typeof z) => z.ZodType;
    }, UFactoryOutput extends ExtensionDataValue<any, any>, UNewOutput extends AnyExtensionDataRef, TExtraInputs extends {
        [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    }>(args: {
        name?: TNewName;
        attachTo?: ExtensionAttachToSpec;
        disabled?: boolean;
        inputs?: TExtraInputs & {
            [KName in keyof T['inputs']]?: `Error: Input '${KName & string}' is already defined in parent definition`;
        };
        output?: Array<UNewOutput>;
        config?: {
            schema: TExtensionConfigSchema & {
                [KName in keyof T['config']]?: `Error: Config key '${KName & string}' is already defined in parent schema`;
            };
        };
        factory(originalFactory: (params: T['params'], context?: {
            config?: T['config'];
            inputs?: ResolveInputValueOverrides<NonNullable<T['inputs']>>;
        }) => ExtensionDataContainer<NonNullable<T['output']>>, context: {
            node: AppNode;
            apis: ApiHolder;
            config: T['config'] & {
                [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
            };
            inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;
        }): Iterable<UFactoryOutput> & VerifyExtensionFactoryOutput<AnyExtensionDataRef extends UNewOutput ? NonNullable<T['output']> : UNewOutput, UFactoryOutput>;
    }): ExtensionDefinition<{
        config: (string extends keyof TExtensionConfigSchema ? {} : {
            [key in keyof TExtensionConfigSchema]: z.infer<ReturnType<TExtensionConfigSchema[key]>>;
        }) & T['config'];
        configInput: (string extends keyof TExtensionConfigSchema ? {} : z.input<z.ZodObject<{
            [key in keyof TExtensionConfigSchema]: ReturnType<TExtensionConfigSchema[key]>;
        }>>) & T['configInput'];
        output: AnyExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;
        inputs: T['inputs'] & TExtraInputs;
        kind: T['kind'];
        name: string | undefined extends TNewName ? T['name'] : TNewName;
        params: T['params'];
    }>;
}
/**
 * A simpler replacement for wrapping up `createExtension` inside a kind or type. This allows for a cleaner API for creating
 * types and instances of those types.
 *
 * @public
 */
declare function createExtensionBlueprint<TParams extends object, UOutput extends AnyExtensionDataRef, TInputs extends {
    [inputName in string]: ExtensionInput<AnyExtensionDataRef, {
        optional: boolean;
        singleton: boolean;
    }>;
}, TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
}, UFactoryOutput extends ExtensionDataValue<any, any>, TKind extends string, TName extends string | undefined = undefined, TDataRefs extends {
    [name in string]: AnyExtensionDataRef;
} = never>(options: CreateExtensionBlueprintOptions<TKind, TName, TParams, UOutput, TInputs, TConfigSchema, UFactoryOutput, TDataRefs>): ExtensionBlueprint<{
    kind: TKind;
    name: TName;
    params: TParams;
    output: UOutput;
    inputs: string extends keyof TInputs ? {} : TInputs;
    config: string extends keyof TConfigSchema ? {} : {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
    };
    configInput: string extends keyof TConfigSchema ? {} : z.input<z.ZodObject<{
        [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
    }>>;
    dataRefs: TDataRefs;
}>;

/**
 * The specification for this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The specifications for a collection of app nodes is all the information needed
 * to build the tree and instantiate the nodes.
 */
interface AppNodeSpec {
    readonly id: string;
    readonly attachTo: ExtensionAttachToSpec;
    readonly extension: Extension<unknown, unknown>;
    readonly disabled: boolean;
    readonly config?: unknown;
    readonly plugin?: FrontendPlugin;
    /**
     * @deprecated Use {@link AppNodeSpec.plugin} instead.
     */
    readonly source?: FrontendPlugin;
}
/**
 * The connections from this {@link AppNode} to other nodes.
 *
 * @public
 * @remarks
 *
 * The app node edges are resolved based on the app node specs, regardless of whether
 * adjacent nodes are disabled or not. If no parent attachment is present or
 */
interface AppNodeEdges {
    readonly attachedTo?: {
        node: AppNode;
        input: string;
    };
    readonly attachments: ReadonlyMap<string, AppNode[]>;
}
/**
 * The instance of this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The app node instance is created when the `factory` function of an extension is called.
 * Instances will only be present for nodes in the app that are connected to the root
 * node and not disabled
 */
interface AppNodeInstance {
    /** Returns a sequence of all extension data refs that were output by this instance */
    getDataRefs(): Iterable<ExtensionDataRef<unknown>>;
    /** Get the output data for a single extension data ref */
    getData<T>(ref: ExtensionDataRef<T>): T | undefined;
}
/**
 * A node in the {@link AppTree}.
 *
 * @public
 */
interface AppNode {
    /** The specification for how this node should be instantiated */
    readonly spec: AppNodeSpec;
    /** The edges from this node to other nodes in the app tree */
    readonly edges: AppNodeEdges;
    /** The instance of this node, if it was instantiated */
    readonly instance?: AppNodeInstance;
}
/**
 * The app tree containing all {@link AppNode}s of the app.
 *
 * @public
 */
interface AppTree {
    /** The root node of the app */
    readonly root: AppNode;
    /** A map of all nodes in the app by ID, including orphaned or disabled nodes */
    readonly nodes: ReadonlyMap<string, AppNode>;
    /** A sequence of all nodes with a parent that is not reachable from the app root node */
    readonly orphans: Iterable<AppNode>;
}
/**
 * The API for interacting with the {@link AppTree}.
 *
 * @public
 */
interface AppTreeApi {
    /**
     * Get the {@link AppTree} for the app.
     */
    getTree(): {
        tree: AppTree;
    };
    /**
     * Get all nodes in the app that are mounted at a given route path.
     */
    getNodesByRoutePath(sourcePath: string): {
        nodes: AppNode[];
    };
}
/**
 * The `ApiRef` of {@link AppTreeApi}.
 *
 * @public
 */
declare const appTreeApiRef: _backstage_core_plugin_api.ApiRef<AppTreeApi>;

/** @public */
interface ExtensionBoundaryProps {
    node: AppNode;
    /**
     * This explicitly marks the extension as routable for the purpose of
     * capturing analytics events. If not provided, the extension boundary will be
     * marked as routable if it outputs a routePath.
     */
    routable?: boolean;
    children: ReactNode;
}
/** @public */
declare function ExtensionBoundary(props: ExtensionBoundaryProps): react_jsx_runtime.JSX.Element;
/** @public */
declare namespace ExtensionBoundary {
    function lazy(appNode: AppNode, loader: () => Promise<JSX.Element>): JSX.Element;
    function lazyComponent<TProps extends {}>(appNode: AppNode, loader: () => Promise<(props: TProps) => JSX.Element>): (props: TProps) => JSX.Element;
}

/** @public */
type ComponentRef<T extends {} = {}> = {
    id: string;
    T: T;
};
/** @public */
declare function createComponentRef<T extends {} = {}>(options: {
    id: string;
}): ComponentRef<T>;

/** @public */
type CoreProgressProps = {};
/** @public */
type CoreNotFoundErrorPageProps = {
    children?: ReactNode;
};
/** @public */
type CoreErrorBoundaryFallbackProps = {
    plugin?: FrontendPlugin;
    error: Error;
    resetError: () => void;
};

/** @public */
declare const coreComponentRefs: {
    progress: ComponentRef<CoreProgressProps>;
    notFoundErrorPage: ComponentRef<CoreNotFoundErrorPageProps>;
    errorBoundaryFallback: ComponentRef<CoreErrorBoundaryFallbackProps>;
};

/**
 * React hook providing access to the current {@link AppNode}.
 *
 * @public
 * @remarks
 *
 * This hook will return the {@link AppNode} for the closest extension. This
 * relies on the extension using the {@link (ExtensionBoundary:function)} component in its
 * implementation, which is included by default for all common blueprints.
 *
 * If the current component is not inside an {@link (ExtensionBoundary:function)}, it will
 * return `undefined`.
 */
declare function useAppNode(): AppNode | undefined;

/**
 * API for looking up components based on component refs.
 *
 * @public
 */
interface ComponentsApi {
    getComponent<T extends {}>(ref: ComponentRef<T>): ComponentType<T>;
}
/**
 * The `ApiRef` of {@link ComponentsApi}.
 *
 * @public
 */
declare const componentsApiRef: _backstage_core_plugin_api.ApiRef<ComponentsApi>;
/**
 * @public
 * Returns the component associated with the given ref.
 */
declare function useComponentRef<T extends {}>(ref: ComponentRef<T>): ComponentType<T>;

/**
 * IconComponent is the common icon type used throughout Backstage when
 * working with and rendering generic icons, including the app system icons.
 *
 * @remarks
 *
 * The type is based on SvgIcon from Material UI, but we do not want the plugin-api
 * package to have a dependency on Material UI, nor do we want the props to be as broad
 * as the SvgIconProps interface.
 *
 * If you have the need to forward additional props from SvgIconProps, you can
 * open an issue or submit a PR to the main Backstage repo. When doing so please
 * also describe your use-case and reasoning of the addition.
 *
 * @public
 */
type IconComponent = ComponentType<{
    fontSize?: 'medium' | 'large' | 'small' | 'inherit';
}>;

/**
 * API for accessing app icons.
 *
 * @public
 */
interface IconsApi {
    getIcon(key: string): IconComponent | undefined;
    listIconKeys(): string[];
}
/**
 * The `ApiRef` of {@link IconsApi}.
 *
 * @public
 */
declare const iconsApiRef: _backstage_core_plugin_api.ApiRef<IconsApi>;

/**
 * A handle for an open dialog that can be used to interact with it.
 *
 * @remarks
 *
 * Dialogs can be opened using either {@link DialogApi.show} or {@link DialogApi.showModal}.
 *
 * @public
 */
interface DialogApiDialog<TResult = unknown> {
    /**
     * Closes the dialog with that provided result.
     *
     * @remarks
     *
     * If the dialog is a modal dialog a result must always be provided. If it's a regular dialog then passing a result is optional.
     */
    close(...args: undefined extends TResult ? [result?: TResult] : [result: TResult]): void;
    /**
     * Replaces the content of the dialog with the provided element or component, causing it to be rerenedered.
     */
    update(elementOrComponent: React.JSX.Element | ((props: {
        dialog: DialogApiDialog<TResult>;
    }) => JSX.Element)): void;
    /**
     * Wait until the dialog is closed and return the result.
     *
     * @remarks
     *
     * If the dialog is a modal dialog a result will always be returned. If it's a regular dialog then the result may be `undefined`.
     */
    result(): Promise<TResult>;
}
/**
 * A Utility API for showing dialogs that render in the React tree and return a result.
 *
 * @public
 */
interface DialogApi {
    /**
     * Opens a modal dialog and returns a handle to it.
     *
     * @remarks
     *
     * This dialog can be closed by calling the `close` method on the returned handle, optionally providing a result.
     * The dialog can also be closed by the user by clicking the backdrop or pressing the escape key.
     *
     * If the dialog is closed without a result, the result will be `undefined`.
     *
     * @example
     *
     * ### Example with inline dialog content
     * ```tsx
     * const dialog = dialogApi.show<boolean>(
     *   <DialogContent>
     *     <DialogTitle>Are you sure?</DialogTitle>
     *     <DialogActions>
     *       <Button onClick={() => dialog.close(true)}>Yes</Button>
     *       <Button onClick={() => dialog.close(false)}>No</Button>
     *     </DialogActions>
     *   </DialogContent>
     * );
     * const result = await dialog.result();
     * ```
     *
     * @example
     *
     * ### Example with separate dialog component
     * ```tsx
     * function CustomDialog({ dialog }: { dialog: DialogApiDialog<boolean | undefined> }) {
     *   return (
     *     <DialogContent>
     *       <DialogTitle>Are you sure?</DialogTitle>
     *       <DialogActions>
     *         <Button onClick={() => dialog.close(true)}>Yes</Button>
     *         <Button onClick={() => dialog.close(false)}>No</Button>
     *       </DialogActions>
     *     </DialogContent>
     *   )
     * }
     * const result = await dialogApi.show(CustomDialog).result();
     * ```
     *
     * @param elementOrComponent - The element or component to render in the dialog. If a component is provided, it will be provided with a `dialog` prop that contains the dialog handle.
     * @public
     */
    show<TResult = {}>(elementOrComponent: JSX.Element | ((props: {
        dialog: DialogApiDialog<TResult | undefined>;
    }) => JSX.Element)): DialogApiDialog<TResult | undefined>;
    /**
     * Opens a modal dialog and returns a handle to it.
     *
     * @remarks
     *
     * This dialog can not be closed in any other way than calling the `close` method on the returned handle and providing a result.
     *
     * @example
     *
     * ### Example with inline dialog content
     * ```tsx
     * const dialog = dialogApi.showModal<boolean>(
     *   <DialogContent>
     *     <DialogTitle>Are you sure?</DialogTitle>
     *     <DialogActions>
     *       <Button onClick={() => dialog.close(true)}>Yes</Button>
     *       <Button onClick={() => dialog.close(false)}>No</Button>
     *     </DialogActions>
     *   </DialogContent>
     * );
     * const result = await dialog.result();
     * ```
     *
     * @example
     *
     * ### Example with separate dialog component
     * ```tsx
     * function CustomDialog({ dialog }: { dialog: DialogApiDialog<boolean> }) {
     *   return (
     *     <DialogContent>
     *       <DialogTitle>Are you sure?</DialogTitle>
     *       <DialogActions>
     *         <Button onClick={() => dialog.close(true)}>Yes</Button>
     *         <Button onClick={() => dialog.close(false)}>No</Button>
     *       </DialogActions>
     *     </DialogContent>
     *   )
     * }
     * const result = await dialogApi.showModal(CustomDialog).result();
     * ```
     *
     * @param elementOrComponent - The element or component to render in the dialog. If a component is provided, it will be provided with a `dialog` prop that contains the dialog handle.
     * @public
     */
    showModal<TResult = {}>(elementOrComponent: JSX.Element | ((props: {
        dialog: DialogApiDialog<TResult>;
    }) => JSX.Element)): DialogApiDialog<TResult>;
}
/**
 * The `ApiRef` of {@link DialogApi}.
 *
 * @public
 */
declare const dialogApiRef: _backstage_core_plugin_api.ApiRef<DialogApi>;

/**
 * TS magic for handling route parameters.
 *
 * @remarks
 *
 * The extra TS magic here is to require a single params argument if the RouteRef
 * had at least one param defined, but require 0 arguments if there are no params defined.
 * Without this we'd have to pass in empty object to all parameter-less RouteRefs
 * just to make TypeScript happy, or we would have to make the argument optional in
 * which case you might forget to pass it in when it is actually required.
 *
 * @public
 */
type RouteFunc<TParams extends AnyRouteRefParams> = (...[params]: TParams extends undefined ? readonly [] : readonly [params: TParams]) => string;
/**
 * @public
 */
type RouteResolutionApiResolveOptions = {
    /**
     * An absolute path to use as a starting point when resolving the route.
     * If no path is provided the route will be resolved from the root of the app.
     */
    sourcePath?: string;
};
/**
 * @public
 */
interface RouteResolutionApi {
    resolve<TParams extends AnyRouteRefParams>(anyRouteRef: RouteRef<TParams> | SubRouteRef<TParams> | ExternalRouteRef<TParams>, options?: RouteResolutionApiResolveOptions): RouteFunc<TParams> | undefined;
}
/**
 * The `ApiRef` of {@link RouteResolutionApi}.
 *
 * @public
 */
declare const routeResolutionApiRef: _backstage_core_plugin_api.ApiRef<RouteResolutionApi>;

/**
 * Represents an event worth tracking in an analytics system that could inform
 * how users of a Backstage instance are using its features.
 *
 * @public
 */
type AnalyticsEvent = {
    /**
     * A string that identifies the event being tracked by the type of action the
     * event represents. Be careful not to encode extra metadata in this string
     * that should instead be placed in the Analytics Context or attributes.
     * Examples include:
     *
     * - view
     * - click
     * - filter
     * - search
     * - hover
     * - scroll
     */
    action: string;
    /**
     * A string that uniquely identifies the object that the action is being
     * taken on. Examples include:
     *
     * - The path of the page viewed
     * - The url of the link clicked
     * - The value that was filtered by
     * - The text that was searched for
     */
    subject: string;
    /**
     * An optional numeric value relevant to the event that could be aggregated
     * by analytics tools. Examples include:
     *
     * - The index or position of the clicked element in an ordered list
     * - The percentage of an element that has been scrolled through
     * - The amount of time that has elapsed since a fixed point
     * - A satisfaction score on a fixed scale
     */
    value?: number;
    /**
     * Optional, additional attributes (representing dimensions or metrics)
     * specific to the event that could be forwarded on to analytics systems.
     */
    attributes?: AnalyticsEventAttributes;
    /**
     * Contextual metadata relating to where the event was captured and by whom.
     * This could include information about the route, plugin, or extension in
     * which an event was captured.
     */
    context: AnalyticsContextValue;
};
/**
 * A structure allowing other arbitrary metadata to be provided by analytics
 * event emitters.
 *
 * @public
 */
type AnalyticsEventAttributes = {
    [attribute in string]: string | boolean | number;
};
/**
 * Represents a tracker with methods that can be called to track events in a
 * configured analytics service.
 *
 * @public
 */
type AnalyticsTracker = {
    captureEvent: (action: string, subject: string, options?: {
        value?: number;
        attributes?: AnalyticsEventAttributes;
    }) => void;
};
/**
 * The Analytics API is used to track user behavior in a Backstage instance.
 *
 * @remarks
 *
 * To instrument your App or Plugin, retrieve an analytics tracker using the
 * useAnalytics() hook. This will return a pre-configured AnalyticsTracker
 * with relevant methods for instrumentation.
 *
 * @public
 */
type AnalyticsApi = {
    /**
     * Primary event handler responsible for compiling and forwarding events to
     * an analytics system.
     */
    captureEvent(event: AnalyticsEvent): void;
};
/**
 * The API reference of {@link AnalyticsApi}.
 *
 * @public
 */
declare const analyticsApiRef: ApiRef<AnalyticsApi>;

/**
 * Gets a pre-configured analytics tracker.
 *
 * @public
 */
declare function useAnalytics(): AnalyticsTracker;

/**
 * Creates utility API extensions.
 *
 * @public
 */
declare const ApiBlueprint: ExtensionBlueprint<{
    kind: "api";
    name: undefined;
    params: {
        factory: AnyApiFactory;
    };
    output: ConfigurableExtensionDataRef<AnyApiFactory, "core.api.factory", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        factory: ConfigurableExtensionDataRef<AnyApiFactory, "core.api.factory", {}>;
    };
}>;

/**
 * Creates extensions that render a React element at the app root, outside of
 * the app layout. This is useful for example for shared popups and similar.
 *
 * @public
 */
declare const AppRootElementBlueprint: ExtensionBlueprint<{
    kind: "app-root-element";
    name: undefined;
    params: {
        element: JSX.Element | (() => JSX.Element);
    };
    output: ConfigurableExtensionDataRef<react.JSX.Element, "core.reactElement", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: never;
}>;

/**
 * Creates a extensions that render a React wrapper at the app root, enclosing
 * the app layout. This is useful for example for adding global React contexts
 * and similar.
 *
 * @public
 */
declare const AppRootWrapperBlueprint: ExtensionBlueprint<{
    kind: "app-root-wrapper";
    name: undefined;
    params: {
        Component: ComponentType<PropsWithChildren<{}>>;
    };
    output: ConfigurableExtensionDataRef<ComponentType<{
        children?: react.ReactNode | undefined;
    }>, "app.root.wrapper", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        component: ConfigurableExtensionDataRef<ComponentType<{
            children?: react.ReactNode | undefined;
        }>, "app.root.wrapper", {}>;
    };
}>;

/** @public */
declare const IconBundleBlueprint: ExtensionBlueprint<{
    kind: "icon-bundle";
    name: undefined;
    params: {
        icons: { [key in string]: IconComponent; };
    };
    output: ConfigurableExtensionDataRef<{
        [x: string]: IconComponent;
    }, "core.icons", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        icons: ConfigurableExtensionDataRef<{
            [x: string]: IconComponent;
        }, "core.icons", {}>;
    };
}>;

/**
 * Creates extensions that make up the items of the nav bar.
 *
 * @public
 */
declare const NavItemBlueprint: ExtensionBlueprint<{
    kind: "nav-item";
    name: undefined;
    params: {
        title: string;
        icon: IconComponent$1;
        routeRef: RouteRef<undefined>;
    };
    output: ConfigurableExtensionDataRef<{
        title: string;
        icon: IconComponent$1;
        routeRef: RouteRef<undefined>;
    }, "core.nav-item.target", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        target: ConfigurableExtensionDataRef<{
            title: string;
            icon: IconComponent$1;
            routeRef: RouteRef<undefined>;
        }, "core.nav-item.target", {}>;
    };
}>;

/**
 * Creates an extension that replaces the logo in the nav bar with your own.
 *
 * @public
 */
declare const NavLogoBlueprint: ExtensionBlueprint<{
    kind: "nav-logo";
    name: undefined;
    params: {
        logoIcon: JSX.Element;
        logoFull: JSX.Element;
    };
    output: ConfigurableExtensionDataRef<{
        logoIcon?: JSX.Element;
        logoFull?: JSX.Element;
    }, "core.nav-logo.logo-elements", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        logoElements: ConfigurableExtensionDataRef<{
            logoIcon?: JSX.Element;
            logoFull?: JSX.Element;
        }, "core.nav-logo.logo-elements", {}>;
    };
}>;

/**
 * Createx extensions that are routable React page components.
 *
 * @public
 */
declare const PageBlueprint: ExtensionBlueprint<{
    kind: "page";
    name: undefined;
    params: {
        defaultPath: string;
        loader: () => Promise<JSX.Element>;
        routeRef?: RouteRef;
    };
    output: ConfigurableExtensionDataRef<react.JSX.Element, "core.reactElement", {}> | ConfigurableExtensionDataRef<string, "core.routing.path", {}> | ConfigurableExtensionDataRef<RouteRef<AnyRouteRefParams>, "core.routing.ref", {
        optional: true;
    }>;
    inputs: {};
    config: {
        path: string | undefined;
    };
    configInput: {
        path?: string | undefined;
    };
    dataRefs: never;
}>;

/** @public */
declare const RouterBlueprint: ExtensionBlueprint<{
    kind: "app-router-component";
    name: undefined;
    params: {
        Component: ComponentType<PropsWithChildren<{}>>;
    };
    output: ConfigurableExtensionDataRef<ComponentType<{
        children?: react.ReactNode | undefined;
    }>, "app.router.wrapper", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        component: ConfigurableExtensionDataRef<ComponentType<{
            children?: react.ReactNode | undefined;
        }>, "app.router.wrapper", {}>;
    };
}>;

/**
 * Creates an extension that replaces the sign in page.
 *
 * @public
 */
declare const SignInPageBlueprint: ExtensionBlueprint<{
    kind: "sign-in-page";
    name: undefined;
    params: {
        loader: () => Promise<ComponentType<SignInPageProps>>;
    };
    output: ConfigurableExtensionDataRef<ComponentType<SignInPageProps>, "core.sign-in-page.component", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        component: ConfigurableExtensionDataRef<ComponentType<SignInPageProps>, "core.sign-in-page.component", {}>;
    };
}>;

/**
 * Creates an extension that adds/replaces an app theme.
 *
 * @public
 */
declare const ThemeBlueprint: ExtensionBlueprint<{
    kind: "theme";
    name: undefined;
    params: {
        theme: AppTheme;
    };
    output: ConfigurableExtensionDataRef<AppTheme, "core.theme.theme", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        theme: ConfigurableExtensionDataRef<AppTheme, "core.theme.theme", {}>;
    };
}>;

/**
 * Creates an extension that adds translations to your app.
 *
 * @public
 */
declare const TranslationBlueprint: ExtensionBlueprint<{
    kind: "translation";
    name: undefined;
    params: {
        resource: TranslationResource | TranslationMessages;
    };
    output: ConfigurableExtensionDataRef<TranslationResource<string> | TranslationMessages<string, {
        [x: string]: string;
    }, boolean>, "core.translation.translation", {}>;
    inputs: {};
    config: {};
    configInput: {};
    dataRefs: {
        translation: ConfigurableExtensionDataRef<TranslationResource<string> | TranslationMessages<string, {
            [x: string]: string;
        }, boolean>, "core.translation.translation", {}>;
    };
}>;

/** @public */
declare function createComponentExtension<TProps extends {}>(options: {
    ref: ComponentRef<TProps>;
    name?: string;
    disabled?: boolean;
    loader: {
        lazy: () => Promise<ComponentType<TProps>>;
    } | {
        sync: () => ComponentType<TProps>;
    };
}): ExtensionDefinition<{
    config: {};
    configInput: {};
    output: ConfigurableExtensionDataRef<{
        ref: ComponentRef;
        impl: ComponentType;
    }, "core.component.component", {}>;
    inputs: {
        [x: string]: ExtensionInput<AnyExtensionDataRef, {
            optional: boolean;
            singleton: boolean;
        }>;
    };
    params: never;
    kind: "component";
    name: string;
}>;
/** @public */
declare namespace createComponentExtension {
    const componentDataRef: ConfigurableExtensionDataRef<{
        ref: ComponentRef;
        impl: ComponentType;
    }, "core.component.component", {}>;
}

export { type AnalyticsApi, AnalyticsContext, type AnalyticsContextValue, type AnalyticsEvent, type AnalyticsEventAttributes, type AnalyticsTracker, type AnyExtensionDataRef, type AnyExternalRoutes, type AnyRouteRefParams, type AnyRoutes, ApiBlueprint, type AppNode, type AppNodeEdges, type AppNodeInstance, type AppNodeSpec, AppRootElementBlueprint, AppRootWrapperBlueprint, type AppTree, type AppTreeApi, type CommonAnalyticsContext, type ComponentRef, type ComponentsApi, type ConfigurableExtensionDataRef, type CoreErrorBoundaryFallbackProps, type CoreNotFoundErrorPageProps, type CoreProgressProps, type CreateExtensionBlueprintOptions, type CreateExtensionOptions, type CreateFrontendFeatureLoaderOptions, type CreateFrontendModuleOptions, type DialogApi, type DialogApiDialog, type Extension, type ExtensionAttachToSpec, type ExtensionBlueprint, type ExtensionBlueprintParameters, ExtensionBoundary, type ExtensionBoundaryProps, type ExtensionDataContainer, type ExtensionDataRef, type ExtensionDataRefToValue, type ExtensionDataValue, type ExtensionDefinition, type ExtensionDefinitionParameters, type ExtensionFactoryMiddleware, type ExtensionInput, type ExternalRouteRef, type FeatureFlagConfig, type FrontendFeature, type FrontendFeatureLoader, type FrontendModule, type FrontendPlugin, type FrontendPluginInfo, type FrontendPluginInfoOptions, IconBundleBlueprint, type IconComponent, type IconsApi, NavItemBlueprint, NavLogoBlueprint, PageBlueprint, type PluginOptions, type PortableSchema, type ResolveInputValueOverrides, type ResolvedExtensionInput, type ResolvedExtensionInputs, type RouteFunc, type RouteRef, type RouteResolutionApi, type RouteResolutionApiResolveOptions, RouterBlueprint, SignInPageBlueprint, type SubRouteRef, ThemeBlueprint, TranslationBlueprint, analyticsApiRef, appTreeApiRef, componentsApiRef, coreComponentRefs, coreExtensionData, createComponentExtension, createComponentRef, createExtension, createExtensionBlueprint, createExtensionDataRef, createExtensionInput, createExternalRouteRef, createFrontendFeatureLoader, createFrontendModule, createFrontendPlugin, createRouteRef, createSubRouteRef, dialogApiRef, iconsApiRef, routeResolutionApiRef, useAnalytics, useAppNode, useComponentRef, useRouteRef, useRouteRefParams };
