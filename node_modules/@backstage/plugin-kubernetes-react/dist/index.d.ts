import { Entity } from '@backstage/catalog-model';
import { ObjectsByEntityResponse, CustomResourceMatcher, ClientPodStatus, GroupedResponses, ClusterAttributes, DetectedError, KubernetesRequestBody, WorkloadsByEntityRequest, CustomObjectsByEntityRequest, ClusterObjects, DetectedErrorsByCluster, ClientContainerStatus } from '@backstage/plugin-kubernetes-common';
import * as react from 'react';
import { ReactNode, FC } from 'react';
import { IObjectMeta, IIoK8sApimachineryPkgApisMetaV1ObjectMeta } from '@kubernetes-models/apimachinery/apis/meta/v1/ObjectMeta';
import { TypeMeta } from '@kubernetes-models/base';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { OAuthApi, OpenIdConnectApi, DiscoveryApi, FetchApi, ProfileInfoApi } from '@backstage/core-plugin-api';
import * as kubernetes_models_v1 from 'kubernetes-models/v1';
import { Event, Pod, IContainer, IContainerStatus } from 'kubernetes-models/v1';
import { JsonObject } from '@backstage/types';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { V2HorizontalPodAutoscaler, V1Job, V1ObjectMeta, V1Pod } from '@kubernetes/client-node';
import * as react_use_esm_useAsyncFn from 'react-use/esm/useAsyncFn';
import { Pod as Pod$1 } from 'kubernetes-models/v1/Pod';

/**
 *
 * @public
 */
interface KubernetesObjects {
    kubernetesObjects?: ObjectsByEntityResponse;
    loading: boolean;
    error?: string;
}
/**
 *
 * @public
 */
declare const useKubernetesObjects: (entity: Entity, intervalMs?: number) => KubernetesObjects;

/**
 * Retrieves the provided custom resources related to the provided entity, refreshes at an interval.
 *
 * @public
 */
declare const useCustomResources: (entity: Entity, customResourceMatchers: CustomResourceMatcher[], intervalMs?: number) => KubernetesObjects;

/**
 * @public
 */
declare const PodNamesWithErrorsContext: react.Context<Set<string>>;

/**
 * @public
 */
declare const PodNamesWithMetricsContext: react.Context<Map<string, ClientPodStatus>>;

/**
 *
 *
 * @public
 */
declare const GroupedResponsesContext: react.Context<GroupedResponses>;

/**
 * @public
 */
declare const ClusterContext: react.Context<ClusterAttributes>;

/**
 * Context for Pod Metrics
 *
 * @public
 */
declare const PodMetricsContext: react.Context<Map<string, ClientPodStatus[]>>;
/**
 * @public
 */
type PodMetricsMatcher = {
    metadata?: IObjectMeta;
};
/**
 * Find metrics matching the provided pod
 *
 * @public
 */
declare const usePodMetrics: (clusterName: string, matcher: PodMetricsMatcher) => ClientPodStatus | undefined;

/**
 * Context for detected errors
 *
 * @public
 */
declare const DetectedErrorsContext: react.Context<DetectedError[]>;
/**
 *
 * @public
 */
type ErrorMatcher = {
    metadata?: IIoK8sApimachineryPkgApisMetaV1ObjectMeta;
} & TypeMeta;
/**
 * Find errors which match the resource
 *
 * @public
 */
declare const useMatchingErrors: (matcher: ErrorMatcher) => DetectedError[];

/** @public */
declare const kubernetesApiRef: _backstage_core_plugin_api.ApiRef<KubernetesApi>;
/** @public */
declare const kubernetesProxyApiRef: _backstage_core_plugin_api.ApiRef<KubernetesProxyApi>;
/** @public */
declare const kubernetesClusterLinkFormatterApiRef: _backstage_core_plugin_api.ApiRef<KubernetesClusterLinkFormatterApi>;
/** @public */
interface KubernetesApi {
    getObjectsByEntity(requestBody: KubernetesRequestBody): Promise<ObjectsByEntityResponse>;
    getClusters(): Promise<{
        name: string;
        authProvider: string;
        oidcTokenProvider?: string;
    }[]>;
    getCluster(clusterName: string): Promise<{
        name: string;
        authProvider: string;
        oidcTokenProvider?: string;
        dashboardUrl?: string;
    } | undefined>;
    getWorkloadsByEntity(request: WorkloadsByEntityRequest): Promise<ObjectsByEntityResponse>;
    getCustomObjectsByEntity(request: CustomObjectsByEntityRequest): Promise<ObjectsByEntityResponse>;
    proxy(options: {
        clusterName: string;
        path: string;
        init?: RequestInit;
    }): Promise<Response>;
}
/** @public */
interface KubernetesProxyApi {
    getPodLogs(request: {
        podName: string;
        namespace: string;
        clusterName: string;
        containerName: string;
        previous?: boolean;
    }): Promise<{
        text: string;
    }>;
    deletePod(request: {
        podName: string;
        namespace: string;
        clusterName: string;
    }): Promise<{
        text: string;
    }>;
    getEventsByInvolvedObjectName(request: {
        clusterName: string;
        involvedObjectName: string;
        namespace: string;
    }): Promise<Event[]>;
}
/**
 * @public
 */
type FormatClusterLinkOptions = {
    dashboardUrl?: string;
    dashboardApp?: string;
    dashboardParameters?: JsonObject;
    object: any;
    kind: string;
};
/** @public */
interface KubernetesClusterLinkFormatterApi {
    formatClusterLink(options: FormatClusterLinkOptions): Promise<string | undefined>;
}

/** @public */
interface KubernetesAuthProvider {
    decorateRequestBodyForAuth(requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(): Promise<{
        token?: string;
    }>;
}
/** @public */
declare const kubernetesAuthProvidersApiRef: _backstage_core_plugin_api.ApiRef<KubernetesAuthProvidersApi>;
/** @public */
interface KubernetesAuthProvidersApi {
    decorateRequestBodyForAuth(authProvider: string, requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(authProvider: string): Promise<{
        token?: string;
    }>;
}

/** @public */
declare class KubernetesAuthProviders implements KubernetesAuthProvidersApi {
    private readonly kubernetesAuthProviderMap;
    constructor(options: {
        microsoftAuthApi: OAuthApi;
        googleAuthApi: OAuthApi;
        oidcProviders?: {
            [key: string]: OpenIdConnectApi;
        };
    });
    decorateRequestBodyForAuth(authProvider: string, requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(authProvider: string): Promise<{
        token?: string;
    }>;
}

/** @public */
declare class GoogleKubernetesAuthProvider implements KubernetesAuthProvider {
    authProvider: OAuthApi;
    constructor(authProvider: OAuthApi);
    decorateRequestBodyForAuth(requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(): Promise<{
        token: string;
    }>;
}

/**
 * No-op KubernetesAuthProvider, authorization will be handled in the kubernetes-backend plugin
 *
 * @public
 */
declare class ServerSideKubernetesAuthProvider implements KubernetesAuthProvider {
    decorateRequestBodyForAuth(requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(): Promise<{}>;
}

/** @public */
declare class OidcKubernetesAuthProvider implements KubernetesAuthProvider {
    providerName: string;
    authProvider: OpenIdConnectApi;
    constructor(providerName: string, authProvider: OpenIdConnectApi);
    decorateRequestBodyForAuth(requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(): Promise<{
        token: string;
    }>;
}

/** @public */
declare class AksKubernetesAuthProvider implements KubernetesAuthProvider {
    private readonly microsoftAuthApi;
    constructor(microsoftAuthApi: OAuthApi);
    decorateRequestBodyForAuth(requestBody: KubernetesRequestBody): Promise<KubernetesRequestBody>;
    getCredentials(): Promise<{
        token?: string;
    }>;
}

/** @public */
declare class KubernetesBackendClient implements KubernetesApi {
    private readonly discoveryApi;
    private readonly fetchApi;
    private readonly kubernetesAuthProvidersApi;
    constructor(options: {
        discoveryApi: DiscoveryApi;
        fetchApi: FetchApi;
        kubernetesAuthProvidersApi: KubernetesAuthProvidersApi;
    });
    private handleResponse;
    private postRequired;
    getCluster(clusterName: string): Promise<{
        name: string;
        authProvider: string;
        oidcTokenProvider?: string;
    }>;
    private getCredentials;
    getObjectsByEntity(requestBody: KubernetesRequestBody): Promise<ObjectsByEntityResponse>;
    getWorkloadsByEntity(request: WorkloadsByEntityRequest): Promise<ObjectsByEntityResponse>;
    getCustomObjectsByEntity(request: CustomObjectsByEntityRequest): Promise<ObjectsByEntityResponse>;
    getClusters(): Promise<{
        name: string;
        authProvider: string;
    }[]>;
    proxy(options: {
        clusterName: string;
        path: string;
        init?: RequestInit;
    }): Promise<Response>;
    private static getKubernetesHeaders;
    private static getKubernetesAuthHeaderByAuthProvider;
}

/**
 * @public
 */
interface ClusterLinksFormatterOptions {
    dashboardUrl?: URL;
    dashboardParameters?: JsonObject;
    object: any;
    kind: string;
}
/**
 * @public
 */
interface ClusterLinksFormatter {
    formatClusterLink(options: ClusterLinksFormatterOptions): Promise<URL>;
}

/** @public */
declare class KubernetesClusterLinkFormatter implements KubernetesClusterLinkFormatterApi {
    private readonly formatters;
    private readonly defaultFormatterName;
    constructor(options: {
        formatters: Record<string, ClusterLinksFormatter>;
        defaultFormatterName: string;
    });
    formatClusterLink(options: FormatClusterLinkOptions): Promise<string | undefined>;
}

/**
 * A client for common requests through the proxy endpoint of the kubernetes backend plugin.
 *
 * @public
 */
declare class KubernetesProxyClient {
    private readonly kubernetesApi;
    constructor(options: {
        kubernetesApi: KubernetesApi;
    });
    private handleText;
    private handleJson;
    getEventsByInvolvedObjectName({ clusterName, involvedObjectName, namespace, }: {
        clusterName: string;
        involvedObjectName: string;
        namespace: string;
    }): Promise<Event[]>;
    getPodLogs({ podName, namespace, clusterName, containerName, previous, }: {
        podName: string;
        namespace: string;
        clusterName: string;
        containerName: string;
        previous?: boolean;
    }): Promise<{
        text: string;
    }>;
    deletePod({ podName, namespace, clusterName, }: {
        podName: string;
        namespace: string;
        clusterName: string;
    }): Promise<{
        text: string;
    }>;
}

/** @public */
declare class AksClusterLinksFormatter implements ClusterLinksFormatter {
    formatClusterLink(options: ClusterLinksFormatterOptions): Promise<URL>;
}

/** @public */
declare class EksClusterLinksFormatter implements ClusterLinksFormatter {
    formatClusterLink(_options: ClusterLinksFormatterOptions): Promise<URL>;
}

/** @public */
declare class GkeClusterLinksFormatter implements ClusterLinksFormatter {
    private readonly googleAuthApi;
    constructor(googleAuthApi: ProfileInfoApi | undefined);
    formatClusterLink(options: ClusterLinksFormatterOptions): Promise<URL>;
}

/** @public */
declare class StandardClusterLinksFormatter implements ClusterLinksFormatter {
    formatClusterLink(options: ClusterLinksFormatterOptions): Promise<URL>;
}

/** @public */
declare class OpenshiftClusterLinksFormatter {
    formatClusterLink(options: ClusterLinksFormatterOptions): Promise<URL>;
}

/** @public */
declare class RancherClusterLinksFormatter implements ClusterLinksFormatter {
    formatClusterLink(options: ClusterLinksFormatterOptions): Promise<URL>;
}

/** @public */
declare class HeadlampClusterLinksFormatter implements ClusterLinksFormatter {
    formatClusterLink(options: ClusterLinksFormatterOptions): Promise<URL>;
    private readonly NAMESPACED_RESOURCES;
    private getHeadlampPath;
}

/** @public */
declare const DEFAULT_FORMATTER_NAME = "standard";
/** @public */
declare function getDefaultFormatters(deps: {
    googleAuthApi: ProfileInfoApi;
}): Record<string, ClusterLinksFormatter>;

/**
 * Props for Cluster
 *
 * @public
 */
type ClusterProps = {
    clusterObjects: ClusterObjects;
    podsWithErrors: Set<string>;
    children?: ReactNode;
};
/**
 * Component for rendering Kubernetes resources in a cluster
 *
 * @public
 */
declare const Cluster: ({ clusterObjects, podsWithErrors }: ClusterProps) => react_jsx_runtime.JSX.Element;

/**
 *
 *
 * @public
 */
type CronJobsAccordionsProps = {
    children?: ReactNode;
};
/**
 *
 *
 * @public
 */
declare const CronJobsAccordions: ({}: CronJobsAccordionsProps) => react_jsx_runtime.JSX.Element;

/**
 *
 *
 * @public
 */
interface CustomResourcesProps {
    children?: ReactNode;
}
/**
 *
 *
 * @public
 */
declare const CustomResources: ({}: CustomResourcesProps) => react_jsx_runtime.JSX.Element;

/**
 *
 *
 * @public
 */
type ErrorPanelProps = {
    entityName: string;
    errorMessage?: string;
    clustersWithErrors?: ClusterObjects[];
    children?: ReactNode;
};
/**
 *
 *
 * @public
 */
declare const ErrorPanel: ({ entityName, errorMessage, clustersWithErrors, }: ErrorPanelProps) => react_jsx_runtime.JSX.Element;

/**
 *
 *
 * @public
 */
type ErrorReportingProps = {
    detectedErrors: DetectedErrorsByCluster;
    clusters: ClusterAttributes[];
};
/**
 *
 *
 * @public
 */
declare const ErrorReporting: ({ detectedErrors, clusters, }: ErrorReportingProps) => react_jsx_runtime.JSX.Element;

/** @public */
declare const HorizontalPodAutoscalerDrawer: (props: {
    hpa: V2HorizontalPodAutoscaler;
    expanded?: boolean;
    children?: ReactNode;
}) => react_jsx_runtime.JSX.Element;

/**
 *
 *
 * @public
 */
type IngressesAccordionsProps = {};
/**
 *
 *
 * @public
 */
declare const IngressesAccordions: ({}: IngressesAccordionsProps) => react_jsx_runtime.JSX.Element;

/**
 *
 *
 * @public
 */
type JobsAccordionsProps = {
    jobs: V1Job[];
    children?: ReactNode;
};
/**
 *
 *
 * @public
 */
declare const JobsAccordions: ({ jobs }: JobsAccordionsProps) => react_jsx_runtime.JSX.Element;

/**
 *
 *
 * @public
 */
type LinkErrorPanelProps = {
    cluster: ClusterAttributes;
    errorMessage?: string;
    children?: ReactNode;
};
/**
 *
 *
 * @public
 */
declare const LinkErrorPanel: ({ cluster, errorMessage, }: LinkErrorPanelProps) => react_jsx_runtime.JSX.Element;
/**
 *
 *
 * @public
 */
interface KubernetesDrawerable {
    metadata?: V1ObjectMeta;
}
/**
 *
 * @public
 */
interface KubernetesStructuredMetadataTableDrawerProps<T extends KubernetesDrawerable> {
    object: T;
    renderObject: (obj: T) => object;
    buttonVariant?: 'h5' | 'subtitle2';
    kind: string;
    expanded?: boolean;
    children?: ReactNode;
}
/**
 *
 * @public
 */
declare const KubernetesStructuredMetadataTableDrawer: <T extends KubernetesDrawerable>({ object, renderObject, kind, buttonVariant, expanded, children, }: KubernetesStructuredMetadataTableDrawerProps<T>) => react_jsx_runtime.JSX.Element;

/**
 * The type of object that can be represented by the Drawer
 *
 * @public
 */
interface KubernetesObject {
    kind: string;
    metadata?: IObjectMeta;
}
/**
 * Props of KubernetesDrawer
 *
 * @public
 */
interface KubernetesDrawerProps {
    open?: boolean;
    kubernetesObject: KubernetesObject;
    label: ReactNode;
    drawerContentsHeader?: ReactNode;
    children?: ReactNode;
}
/**
 * Button/Drawer component for Kubernetes Objects
 *
 * @public
 */
declare const KubernetesDrawer: ({ open, label, drawerContentsHeader, kubernetesObject, children, }: KubernetesDrawerProps) => react_jsx_runtime.JSX.Element;

/**
 * Props of ManifestYaml
 *
 * @public
 */
interface ManifestYamlProps {
    object: object;
}
/**
 * Renders a Kubernetes object as a YAML code snippet
 *
 * @public
 */
declare const ManifestYaml: ({ object }: ManifestYamlProps) => react_jsx_runtime.JSX.Element;

/**
 * Wraps a pod with the associated detected errors and cluster
 *
 * @public
 */
interface PodAndErrors {
    cluster: ClusterAttributes;
    pod: Pod;
    errors: DetectedError[];
}

/**
 * Props for PodDrawer
 *
 * @public
 */
interface PodDrawerProps {
    open?: boolean;
    podAndErrors: PodAndErrors;
}
/**
 * A Drawer for Kubernetes Pods
 *
 * @public
 */
declare const PodDrawer: ({ podAndErrors, open }: PodDrawerProps) => react_jsx_runtime.JSX.Element;

/**
 * Contains the details needed to make a log request to Kubernetes, except the container name
 *
 * @public
 */
interface PodScope {
    podName: string;
    podNamespace: string;
    cluster: ClusterAttributes;
}
/**
 * Contains the details needed to make a log request to Kubernetes
 *
 * @public
 */
interface ContainerScope extends PodScope {
    containerName: string;
}

/**
 * Props for PodLogs
 *
 * @public
 */
interface PodLogsProps {
    containerScope: ContainerScope;
    previous?: boolean;
}
/**
 * Shows the logs for the given pod
 *
 * @public
 */
declare const PodLogs: FC<PodLogsProps>;

/**
 * Props for PodLogsDialog
 *
 * @public
 */
interface PodLogsDialogProps {
    containerScope: ContainerScope;
}
/**
 * Shows the logs for the given pod in a Dialog
 *
 * @public
 */
declare const PodLogsDialog: ({ containerScope }: PodLogsDialogProps) => react_jsx_runtime.JSX.Element;

/**
 * Arguments for usePodLogs
 *
 * @public
 */
interface PodLogsOptions {
    containerScope: ContainerScope;
    previous?: boolean;
}
/**
 * Retrieves the logs for the given pod
 *
 * @public
 */
declare const usePodLogs: ({ containerScope, previous }: PodLogsOptions) => react_use_esm_useAsyncFn.AsyncState<{
    text: string;
}>;

/**
 * Props for ContainerCard
 *
 * @public
 */
interface ContainerCardProps {
    podScope: PodScope;
    containerSpec?: IContainer;
    containerStatus: IContainerStatus;
    containerMetrics?: ClientContainerStatus;
}
/**
 * Shows details about a container within a pod
 *
 * @public
 */
declare const ContainerCard: FC<ContainerCardProps>;

/**
 * Props for PendingPodContent
 *
 * @public
 */
interface PendingPodContentProps {
    pod: Pod;
}
/**
 * Shows details about pod's conditions as it starts
 *
 * @public
 */
declare const PendingPodContent: ({ pod }: PendingPodContentProps) => react_jsx_runtime.JSX.Element;

/**
 * Props for FixDialog
 *
 * @public
 */
interface FixDialogProps {
    open?: boolean;
    clusterName: string;
    pod: Pod$1;
    error: DetectedError;
}
/**
 * A dialog for fixing detected Kubernetes errors
 *
 * @public
 */
declare const FixDialog: FC<FixDialogProps>;

/**
 * Props for Events
 *
 * @public
 */
interface EventsContentProps {
    warningEventsOnly?: boolean;
    events: Event[];
}
/**
 * Shows given Kubernetes events
 *
 * @public
 */
declare const EventsContent: ({ events, warningEventsOnly, }: EventsContentProps) => react_jsx_runtime.JSX.Element;
/**
 * Props for Events
 *
 * @public
 */
interface EventsProps {
    involvedObjectName: string;
    namespace: string;
    clusterName: string;
    warningEventsOnly?: boolean;
}
/**
 * Retrieves and shows Kubernetes events for the given object
 *
 * @public
 */
declare const Events: ({ involvedObjectName, namespace, clusterName, warningEventsOnly, }: EventsProps) => react_jsx_runtime.JSX.Element;

/**
 * Arguments for useEvents
 *
 * @public
 */
interface EventsOptions {
    involvedObjectName: string;
    namespace: string;
    clusterName: string;
}
/**
 * Retrieves the events for the given object
 *
 * @public
 */
declare const useEvents: ({ involvedObjectName, namespace, clusterName, }: EventsOptions) => react_use_esm_useAsyncFn.AsyncState<kubernetes_models_v1.Event[]>;

/**
 * Props for ErrorList
 *
 * @public
 */
interface ErrorListProps {
    podAndErrors: PodAndErrors[];
}
/**
 * Shows a list of errors found on a Pod
 *
 * @public
 */
declare const ErrorList: ({ podAndErrors }: ErrorListProps) => react_jsx_runtime.JSX.Element;

/**
 *
 *
 * @public
 */
declare const READY_COLUMNS: PodColumns;
/**
 *
 *
 * @public
 */
declare const RESOURCE_COLUMNS: PodColumns;
/**
 *
 *
 * @public
 */
type PodColumns = 'READY' | 'RESOURCE';
/**
 *
 *
 * @public
 */
type PodsTablesProps = {
    pods: Pod$1 | V1Pod[];
    extraColumns?: PodColumns[];
    children?: ReactNode;
};
/**
 *
 *
 * @public
 */
declare const PodsTable: ({ pods, extraColumns }: PodsTablesProps) => react_jsx_runtime.JSX.Element;

/**
 *
 *
 * @public
 */
type ServicesAccordionsProps = {};
/**
 *
 *
 * @public
 */
declare const ServicesAccordions: ({}: ServicesAccordionsProps) => react_jsx_runtime.JSX.Element;

/**
 * Context for Pod Metrics
 *
 * @public
 */
interface ResourceUtilizationProps {
    compressed?: boolean;
    title: string;
    usage: number | string;
    total: number | string;
    totalFormatted: string;
}
/**
 * Context for Pod Metrics
 *
 * @public
 */
declare const ResourceUtilization: ({ compressed, title, usage, total, totalFormatted, }: ResourceUtilizationProps) => react_jsx_runtime.JSX.Element;

/**
 * Props drilled down to the PodExecTerminal component
 *
 * @public
 */
interface PodExecTerminalProps {
    cluster: ClusterAttributes;
    containerName: string;
    podName: string;
    podNamespace: string;
}
/**
 * Executes a `/bin/sh` process in the given pod's container and opens a terminal connected to it
 *
 * @public
 */
declare const PodExecTerminal: (props: PodExecTerminalProps) => react_jsx_runtime.JSX.Element;

/**
 * Opens a terminal connected to the given pod's container in a dialog
 *
 * @public
 */
declare const PodExecTerminalDialog: (props: PodExecTerminalProps) => false | react_jsx_runtime.JSX.Element | undefined;

export { AksClusterLinksFormatter, AksKubernetesAuthProvider, Cluster, ClusterContext, type ClusterLinksFormatter, type ClusterLinksFormatterOptions, type ClusterProps, ContainerCard, type ContainerCardProps, type ContainerScope, CronJobsAccordions, type CronJobsAccordionsProps, CustomResources, type CustomResourcesProps, DEFAULT_FORMATTER_NAME, DetectedErrorsContext, EksClusterLinksFormatter, ErrorList, type ErrorListProps, type ErrorMatcher, ErrorPanel, type ErrorPanelProps, ErrorReporting, type ErrorReportingProps, Events, EventsContent, type EventsContentProps, type EventsOptions, type EventsProps, FixDialog, type FixDialogProps, type FormatClusterLinkOptions, GkeClusterLinksFormatter, GoogleKubernetesAuthProvider, GroupedResponsesContext, HeadlampClusterLinksFormatter, HorizontalPodAutoscalerDrawer, IngressesAccordions, type IngressesAccordionsProps, JobsAccordions, type JobsAccordionsProps, type KubernetesApi, type KubernetesAuthProvider, KubernetesAuthProviders, type KubernetesAuthProvidersApi, KubernetesBackendClient, KubernetesClusterLinkFormatter, type KubernetesClusterLinkFormatterApi, KubernetesDrawer, type KubernetesDrawerProps, type KubernetesDrawerable, type KubernetesObject, type KubernetesObjects, type KubernetesProxyApi, KubernetesProxyClient, KubernetesStructuredMetadataTableDrawer, type KubernetesStructuredMetadataTableDrawerProps, LinkErrorPanel, type LinkErrorPanelProps, ManifestYaml, type ManifestYamlProps, OidcKubernetesAuthProvider, OpenshiftClusterLinksFormatter, PendingPodContent, type PendingPodContentProps, type PodAndErrors, type PodColumns, PodDrawer, type PodDrawerProps, PodExecTerminal, PodExecTerminalDialog, type PodExecTerminalProps, PodLogs, PodLogsDialog, type PodLogsDialogProps, type PodLogsOptions, type PodLogsProps, PodMetricsContext, type PodMetricsMatcher, PodNamesWithErrorsContext, PodNamesWithMetricsContext, type PodScope, PodsTable, type PodsTablesProps, READY_COLUMNS, RESOURCE_COLUMNS, RancherClusterLinksFormatter, ResourceUtilization, type ResourceUtilizationProps, ServerSideKubernetesAuthProvider, ServicesAccordions, type ServicesAccordionsProps, StandardClusterLinksFormatter, getDefaultFormatters, kubernetesApiRef, kubernetesAuthProvidersApiRef, kubernetesClusterLinkFormatterApiRef, kubernetesProxyApiRef, useCustomResources, useEvents, useKubernetesObjects, useMatchingErrors, usePodLogs, usePodMetrics };
