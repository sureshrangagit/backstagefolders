import { jsx, jsxs } from 'react/jsx-runtime';
import { StructuredMetadataTable } from '@backstage/core-components';
import Card from '@material-ui/core/Card';
import CardActions from '@material-ui/core/CardActions';
import CardContent from '@material-ui/core/CardContent';
import CardHeader from '@material-ui/core/CardHeader';
import Grid from '@material-ui/core/Grid';
import Typography from '@material-ui/core/Typography';
import { DateTime } from 'luxon';
import '@backstage/core-plugin-api';
import { useIsPodExecTerminalEnabled } from '../../../hooks/useIsPodExecTerminalEnabled.esm.js';
import 'react-use/esm/useAsync';
import '../../../api/types.esm.js';
import 'react';
import 'react-use/esm/useInterval';
import 'react-use/esm/useAsyncRetry';
import '../../../kubernetes-auth-provider/types.esm.js';
import '../../../hooks/PodNamesWithErrors.esm.js';
import '../../../hooks/PodNamesWithMetrics.esm.js';
import '../../../hooks/GroupedResponses.esm.js';
import '../../../hooks/Cluster.esm.js';
import '../../../hooks/usePodMetrics.esm.js';
import '../../../hooks/useMatchingErrors.esm.js';
import { formatMillicores, bytesToMiB } from '../../../utils/resources.esm.js';
import { PodExecTerminalDialog } from '../../PodExecTerminal/PodExecTerminalDialog.esm.js';
import { ResourceUtilization } from '../../ResourceUtilization/ResourceUtilization.esm.js';
import '@material-ui/core/Paper';
import '@material-ui/lab/Skeleton';
import { PodLogsDialog } from '../PodLogs/PodLogsDialog.esm.js';

const getContainerHealthChecks = (containerSpec, containerStatus) => {
  const healthCheck = {
    "not waiting to start": containerStatus.state?.waiting === void 0,
    "no restarts": containerStatus.restartCount === 0
  };
  if (containerStatus.state?.terminated?.reason === "Completed") {
    return healthCheck;
  }
  Object.assign(
    healthCheck,
    { started: !!containerStatus.started },
    { ready: containerStatus.ready },
    { "readiness probe set": containerSpec?.readinessProbe !== void 0 }
  );
  if (containerSpec && containerSpec?.livenessProbe !== void 0) {
    Object.assign(healthCheck, {
      "liveness probe set": containerSpec.livenessProbe
    });
  }
  return healthCheck;
};
const getCurrentState = (containerStatus) => {
  return containerStatus.state?.waiting?.reason || containerStatus.state?.terminated?.reason || (containerStatus.state?.running !== void 0 ? "Running" : "Unknown");
};
const getStartedAtTime = (containerStatus) => {
  return containerStatus.state?.running?.startedAt || containerStatus.state?.terminated?.startedAt;
};
const ContainerDatetime = ({ prefix, dateTime }) => {
  return /* @__PURE__ */ jsxs(Typography, { variant: "subtitle2", children: [
    prefix,
    ":",
    " ",
    DateTime.fromISO(dateTime).toRelative({
      locale: "en"
    })
  ] });
};
const ContainerCard = ({
  podScope,
  containerSpec,
  containerStatus,
  containerMetrics
}) => {
  const isPodExecTerminalEnabled = useIsPodExecTerminalEnabled();
  if (containerSpec === void 0) {
    return /* @__PURE__ */ jsx(Typography, { children: "error reading pod from cluster" });
  }
  const containerStartedTime = getStartedAtTime(containerStatus);
  const containerFinishedTime = containerStatus.state?.terminated?.finishedAt;
  return /* @__PURE__ */ jsxs(Card, { children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: containerStatus.name,
        subheader: containerStatus.image
      }
    ),
    /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsxs(Grid, { container: true, children: [
      /* @__PURE__ */ jsxs(Grid, { item: true, xs: 12, children: [
        containerStartedTime && /* @__PURE__ */ jsx(
          ContainerDatetime,
          {
            prefix: "Started",
            dateTime: containerStartedTime
          }
        ),
        containerFinishedTime && /* @__PURE__ */ jsx(
          ContainerDatetime,
          {
            prefix: "Completed",
            dateTime: containerFinishedTime
          }
        ),
        containerStartedTime && containerFinishedTime && /* @__PURE__ */ jsxs(Typography, { variant: "subtitle2", children: [
          "Execution time:",
          " ",
          DateTime.fromISO(containerFinishedTime).diff(DateTime.fromISO(containerStartedTime), [
            "hours",
            "minutes",
            "seconds"
          ]).toHuman()
        ] })
      ] }),
      /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsxs(Typography, { variant: "subtitle2", children: [
        "Status: ",
        getCurrentState(containerStatus)
      ] }) }),
      containerStatus.restartCount > 0 && /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsxs(Typography, { variant: "subtitle2", children: [
        "Restarts: ",
        containerStatus.restartCount
      ] }) }),
      /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsx(Typography, { variant: "subtitle2", children: "Container health" }) }),
      /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
        StructuredMetadataTable,
        {
          metadata: getContainerHealthChecks(
            containerSpec,
            containerStatus
          ),
          options: { nestedValuesAsYaml: true }
        }
      ) }),
      containerMetrics && /* @__PURE__ */ jsxs(Grid, { container: true, item: true, xs: 12, spacing: 0, children: [
        /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsx(Typography, { variant: "subtitle1", children: "Resource utilization" }) }),
        /* @__PURE__ */ jsxs(Grid, { item: true, xs: 12, style: { minHeight: "5rem" }, children: [
          /* @__PURE__ */ jsx(
            ResourceUtilization,
            {
              compressed: true,
              title: "CPU requests",
              usage: containerMetrics.cpuUsage.currentUsage,
              total: containerMetrics.cpuUsage.requestTotal,
              totalFormatted: formatMillicores(
                containerMetrics.cpuUsage.requestTotal
              )
            }
          ),
          /* @__PURE__ */ jsx(
            ResourceUtilization,
            {
              compressed: true,
              title: "CPU limits",
              usage: containerMetrics.cpuUsage.currentUsage,
              total: containerMetrics.cpuUsage.limitTotal,
              totalFormatted: formatMillicores(
                containerMetrics.cpuUsage.limitTotal
              )
            }
          ),
          /* @__PURE__ */ jsx(
            ResourceUtilization,
            {
              compressed: true,
              title: "Memory requests",
              usage: containerMetrics.memoryUsage.currentUsage,
              total: containerMetrics.memoryUsage.requestTotal,
              totalFormatted: bytesToMiB(
                containerMetrics.memoryUsage.requestTotal
              )
            }
          ),
          /* @__PURE__ */ jsx(
            ResourceUtilization,
            {
              compressed: true,
              title: "Memory limits",
              usage: containerMetrics.memoryUsage.currentUsage,
              total: containerMetrics.memoryUsage.limitTotal,
              totalFormatted: bytesToMiB(
                containerMetrics.memoryUsage.limitTotal
              )
            }
          )
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxs(CardActions, { children: [
      /* @__PURE__ */ jsx(
        PodLogsDialog,
        {
          containerScope: {
            containerName: containerStatus.name,
            ...podScope
          }
        }
      ),
      isPodExecTerminalEnabled && /* @__PURE__ */ jsx(
        PodExecTerminalDialog,
        {
          cluster: podScope.cluster,
          containerName: containerStatus.name,
          podName: podScope.podName,
          podNamespace: podScope.podNamespace
        }
      )
    ] })
  ] });
};

export { ContainerCard };
//# sourceMappingURL=ContainerCard.esm.js.map
