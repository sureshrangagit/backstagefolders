{"version":3,"file":"HostDiscovery.cjs.js","sources":["../../../src/entrypoints/discovery/HostDiscovery.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport {\n  DiscoveryService,\n  LoggerService,\n  RootConfigService,\n} from '@backstage/backend-plugin-api';\nimport { readHttpServerOptions } from '../rootHttpRouter/http/config';\nimport { SrvResolvers } from './SrvResolvers';\nimport { trimEnd } from 'lodash';\n\ntype Resolver = (pluginId: string) => Promise<string>;\n\n/**\n * A list of target base URLs and their associated plugins.\n *\n * @public\n */\nexport interface HostDiscoveryEndpoint {\n  /**\n   * The target base URL to use for the given set of plugins. Note that this\n   * needs to be a full URL _including_ the protocol and path parts that fully\n   * address the root of a plugin's API endpoints.\n   *\n   * @remarks\n   *\n   * Can be either a single URL or an object where you can explicitly give a\n   * dedicated URL for internal (as seen from the backend) and/or external (as\n   * seen from the frontend) lookups.\n   *\n   * The default behavior is to use the backend base URL for external lookups,\n   * and a URL formed from the `.listen` and `.https` configs for internal\n   * lookups. Adding discovery endpoints as described here overrides one or both\n   * of those behaviors for a given set of plugins.\n   *\n   * URLs can be in the form of a regular HTTP or HTTPS URL if you are using\n   * A/AAAA/CNAME records or IP addresses. Specifically for internal URLs, if\n   * you add `+src` to the protocol part then the hostname is treated as an SRV\n   * record name and resolved. For example, if you pass in\n   * `http+srv://<record>/path` then the record part is resolved into an\n   * actual host and port (with random weighted choice as usual when there is\n   * more than one match).\n   *\n   * Any strings with `{{pluginId}}` or `{{ pluginId }}` placeholders in them\n   * will have them replaced with the plugin ID.\n   *\n   * Example URLs:\n   *\n   * - `https://internal.example.com/secure/api/{{ pluginId }}`\n   * - `http+srv://backstage-plugin-{{pluginId}}.http.services.company.net/api/{{pluginId}}`\n   *   (can only be used in the `internal` key)\n   */\n  target:\n    | string\n    | {\n        internal?: string;\n        external?: string;\n      };\n\n  /**\n   * Array of plugins which use that target base URL.\n   *\n   * The special value `*` can be used to match all plugins.\n   */\n  plugins: string[];\n}\n\n/**\n * Options for the {@link HostDiscovery} class.\n *\n * @public\n */\nexport interface HostDiscoveryOptions {\n  /**\n   * The logger to use.\n   */\n  logger: LoggerService;\n\n  /**\n   * A default set of endpoints to use.\n   *\n   * @remarks\n   *\n   * These endpoints have lower priority than any that are defined in\n   * app-config, but higher priority than the fallback ones.\n   *\n   * This parameter is usedful for example if you want to provide a shared\n   * library of core services to your plugin developers, which is set up for the\n   * default behaviors in your org. This alleviates the need for replicating any\n   * given set of endpoint config in every backend that you deploy.\n   */\n  defaultEndpoints?: HostDiscoveryEndpoint[];\n}\n\n/**\n * A basic {@link @backstage/backend-plugin-api#DiscoveryService} implementation\n * that can handle plugins that are hosted in a single or multiple deployments.\n *\n * @public\n * @remarks\n *\n * Configuration is read from the `backend` config section, specifically the\n * `.baseUrl` for discovering the external URL, and the `.listen` and `.https`\n * config for the internal one. The fixed base path for these is `/api`, meaning\n * for example the default full internal path for the `catalog` plugin typically\n * will be `http://localhost:7007/api/catalog`.\n *\n * Those defaults can be overridden by providing a target and corresponding\n * plugins in `discovery.endpoints`, e.g.:\n *\n * ```yaml\n * discovery:\n *   endpoints:\n *     # Set a static internal and external base URL for a plugin\n *     - target: https://internal.example.com/internal-catalog\n *       plugins: [catalog]\n *     # Sets a dynamic internal and external base URL pattern for two plugins\n *     - target: https://internal.example.com/secure/api/{{pluginId}}\n *       plugins: [auth, permission]\n *     # Sets a dynamic base URL pattern for only the internal resolution for all\n *     # other plugins, while leaving the external resolution unaffected\n *     - target:\n *         internal: http+srv://backstage-plugin-{{pluginId}}.http.${SERVICE_DOMAIN}/api/{{pluginId}}\n *       plugins: [*]\n * ```\n */\nexport class HostDiscovery implements DiscoveryService {\n  #srvResolver: SrvResolvers;\n  #internalResolvers: Map<string, Resolver> = new Map();\n  #externalResolvers: Map<string, Resolver> = new Map();\n  #internalFallbackResolver: Resolver = async () => {\n    throw new Error('Not initialized');\n  };\n  #externalFallbackResolver: Resolver = async () => {\n    throw new Error('Not initialized');\n  };\n\n  static fromConfig(config: RootConfigService, options?: HostDiscoveryOptions) {\n    const discovery = new HostDiscovery(new SrvResolvers());\n\n    discovery.#updateResolvers(config, options?.defaultEndpoints);\n    config.subscribe?.(() => {\n      try {\n        discovery.#updateResolvers(config, options?.defaultEndpoints);\n      } catch (e) {\n        options?.logger.error(`Failed to update discovery service: ${e}`);\n      }\n    });\n\n    return discovery;\n  }\n\n  private constructor(srvResolver: SrvResolvers) {\n    this.#srvResolver = srvResolver;\n    this.#internalResolvers = new Map();\n    this.#externalResolvers = new Map();\n    this.#internalFallbackResolver = () => {\n      throw new Error('Not initialized');\n    };\n    this.#externalFallbackResolver = () => {\n      throw new Error('Not initialized');\n    };\n  }\n\n  async getBaseUrl(pluginId: string): Promise<string> {\n    const resolver =\n      this.#internalResolvers.get(pluginId) ??\n      this.#internalResolvers.get('*') ??\n      this.#internalFallbackResolver;\n    return await resolver(pluginId);\n  }\n\n  async getExternalBaseUrl(pluginId: string): Promise<string> {\n    const resolver =\n      this.#externalResolvers.get(pluginId) ??\n      this.#externalResolvers.get('*') ??\n      this.#externalFallbackResolver;\n    return await resolver(pluginId);\n  }\n\n  #updateResolvers(config: Config, defaultEndpoints?: HostDiscoveryEndpoint[]) {\n    this.#updateFallbackResolvers(config);\n    this.#updatePluginResolvers(config, defaultEndpoints);\n  }\n\n  #updateFallbackResolvers(config: Config) {\n    const backendBaseUrl = trimEnd(config.getString('backend.baseUrl'), '/');\n\n    const {\n      listen: { host: listenHost = '::', port: listenPort },\n    } = readHttpServerOptions(config.getConfig('backend'));\n    const protocol = config.has('backend.https') ? 'https' : 'http';\n\n    // Translate bind-all to localhost, and support IPv6\n    let host = listenHost;\n    if (host === '::' || host === '') {\n      // We use localhost instead of ::1, since IPv6-compatible systems should default\n      // to using IPv6 when they see localhost, but if the system doesn't support IPv6\n      // things will still work.\n      host = 'localhost';\n    } else if (host === '0.0.0.0') {\n      host = '127.0.0.1';\n    }\n    if (host.includes(':')) {\n      host = `[${host}]`;\n    }\n\n    this.#internalFallbackResolver = this.#makeResolver(\n      `${protocol}://${host}:${listenPort}/api/{{pluginId}}`,\n      false,\n    );\n    this.#externalFallbackResolver = this.#makeResolver(\n      `${backendBaseUrl}/api/{{pluginId}}`,\n      false,\n    );\n  }\n\n  #updatePluginResolvers(\n    config: Config,\n    defaultEndpoints?: HostDiscoveryEndpoint[],\n  ) {\n    // Start out with the default endpoints, if any\n    const endpoints = defaultEndpoints?.slice() ?? [];\n\n    // Allow config to override the default endpoints\n    const endpointConfigs = config.getOptionalConfigArray(\n      'discovery.endpoints',\n    );\n    for (const endpointConfig of endpointConfigs ?? []) {\n      if (typeof endpointConfig.get('target') === 'string') {\n        endpoints.push({\n          target: endpointConfig.getString('target'),\n          plugins: endpointConfig.getStringArray('plugins'),\n        });\n      } else {\n        endpoints.push({\n          target: {\n            internal: endpointConfig.getOptionalString('target.internal'),\n            external: endpointConfig.getOptionalString('target.external'),\n          },\n          plugins: endpointConfig.getStringArray('plugins'),\n        });\n      }\n    }\n\n    // Build up a new set of resolvers\n    const internalResolvers: Map<string, Resolver> = new Map();\n    const externalResolvers: Map<string, Resolver> = new Map();\n    for (const { target, plugins } of endpoints) {\n      let internalResolver: Resolver | undefined;\n      let externalResolver: Resolver | undefined;\n\n      if (typeof target === 'string') {\n        internalResolver = externalResolver = this.#makeResolver(target, false);\n      } else {\n        if (target.internal) {\n          internalResolver = this.#makeResolver(target.internal, true);\n        }\n        if (target.external) {\n          externalResolver = this.#makeResolver(target.external, false);\n        }\n      }\n\n      if (internalResolver) {\n        for (const pluginId of plugins) {\n          internalResolvers.set(pluginId, internalResolver);\n        }\n      }\n      if (externalResolver) {\n        for (const pluginId of plugins) {\n          externalResolvers.set(pluginId, externalResolver);\n        }\n      }\n    }\n\n    // Only persist if no errors were thrown above\n    this.#internalResolvers = internalResolvers;\n    this.#externalResolvers = externalResolvers;\n  }\n\n  #makeResolver(urlPattern: string, allowSrv: boolean): Resolver {\n    const withPluginId = (pluginId: string, url: string) => {\n      return url.replace(\n        /\\{\\{\\s*pluginId\\s*\\}\\}/g,\n        encodeURIComponent(pluginId),\n      );\n    };\n\n    if (!this.#srvResolver.isSrvUrl(urlPattern)) {\n      return async pluginId => withPluginId(pluginId, urlPattern);\n    }\n\n    if (!allowSrv) {\n      throw new Error(\n        `SRV resolver URLs cannot be used in the target for external endpoints`,\n      );\n    }\n\n    const lazyResolvers = new Map<string, () => Promise<string>>();\n    return async pluginId => {\n      let lazyResolver = lazyResolvers.get(pluginId);\n      if (!lazyResolver) {\n        lazyResolver = this.#srvResolver.getResolver(\n          withPluginId(pluginId, urlPattern),\n        );\n        lazyResolvers.set(pluginId, lazyResolver);\n      }\n      return await lazyResolver();\n    };\n  }\n}\n"],"names":["SrvResolvers","config","trimEnd","readHttpServerOptions"],"mappings":"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"}