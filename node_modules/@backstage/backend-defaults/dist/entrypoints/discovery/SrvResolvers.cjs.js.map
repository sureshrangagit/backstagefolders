{"version":3,"file":"SrvResolvers.cjs.js","sources":["../../../src/entrypoints/discovery/SrvResolvers.ts"],"sourcesContent":["/*\n * Copyright 2025 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ForwardedError, InputError, NotFoundError } from '@backstage/errors';\nimport { resolveSrv, SrvRecord } from 'dns';\n\nconst PROTOCOL_SUFFIX = '+srv:';\n\n/**\n * Helps with resolution and caching of SRV lookups.\n *\n * Supports URLs on the form `http+srv://myplugin.services.region.example.net/api/myplugin`\n */\nexport class SrvResolvers {\n  readonly #cache: Map<string, Promise<SrvRecord[]>>;\n  readonly #cacheTtlMillis: number;\n  readonly #resolveSrv: (host: string) => Promise<SrvRecord[]>;\n\n  constructor(options?: {\n    resolveSrv?: (host: string) => Promise<SrvRecord[]>;\n    cacheTtlMillis?: number;\n  }) {\n    this.#cache = new Map();\n    this.#cacheTtlMillis = options?.cacheTtlMillis ?? 1000;\n    this.#resolveSrv =\n      options?.resolveSrv ??\n      (host =>\n        new Promise((resolve, reject) => {\n          resolveSrv(host, (err, result) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(result);\n            }\n          });\n        }));\n  }\n\n  isSrvUrl(url: string): boolean {\n    try {\n      this.#parseSrvUrl(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get a resolver function for a given SRV form URL.\n   *\n   * @param url An SRV form URL, e.g. `http+srv://myplugin.services.region.example.net/api/myplugin`\n   * @returns A function that returns resolved URLs, e.g. `http://1234abcd.region.example.net:8080/api/myplugin`\n   */\n  getResolver(url: string): () => Promise<string> {\n    const { protocol, host, path } = this.#parseSrvUrl(url);\n    return () =>\n      this.#resolveHost(host).then(\n        resolved => `${protocol}://${resolved}${path}`,\n      );\n  }\n\n  /**\n   * Attempts to parse out the relevant parts of an SRV URL.\n   */\n  #parseSrvUrl(url: string): { protocol: string; host: string; path: string } {\n    let parsedUrl: URL;\n    try {\n      parsedUrl = new URL(url);\n    } catch {\n      throw new InputError(\n        `SRV resolver expected a valid URL starting with http(s)+srv:// but got '${url}'`,\n      );\n    }\n    if (!parsedUrl.protocol?.endsWith(PROTOCOL_SUFFIX) || !parsedUrl.hostname) {\n      throw new InputError(\n        `SRV resolver expected a URL with protocol http(s)+srv:// but got '${url}'`,\n      );\n    }\n    if (parsedUrl.port) {\n      throw new InputError(\n        `SRV resolver URLs cannot contain a port but got '${url}'`,\n      );\n    }\n    if (parsedUrl.username || parsedUrl.password) {\n      throw new InputError(\n        `SRV resolver URLs cannot contain username or password but got '${url}'`,\n      );\n    }\n    if (parsedUrl.search || parsedUrl.hash) {\n      throw new InputError(\n        `SRV resolver URLs cannot contain search params or a hash but got '${url}'`,\n      );\n    }\n\n    const protocol = parsedUrl.protocol.substring(\n      0,\n      parsedUrl.protocol.length - PROTOCOL_SUFFIX.length,\n    );\n    const host = parsedUrl.hostname;\n    const path = parsedUrl.pathname.replace(/\\/+$/, '');\n\n    if (!['http', 'https'].includes(protocol)) {\n      throw new InputError(\n        `SRV URLs must be based on http or https but got '${url}'`,\n      );\n    }\n\n    return { protocol, host, path };\n  }\n\n  /**\n   * Resolves a single SRV record name to a host:port string.\n   */\n  #resolveHost(host: string): Promise<string> {\n    let records = this.#cache.get(host);\n    if (!records) {\n      records = this.#resolveSrv(host).then(\n        result => {\n          if (!result.length) {\n            throw new NotFoundError(`No SRV records found for ${host}`);\n          }\n          return result;\n        },\n        err => {\n          throw new ForwardedError(`Failed SRV resolution for ${host}`, err);\n        },\n      );\n      this.#cache.set(host, records);\n      setTimeout(() => {\n        this.#cache.delete(host);\n      }, this.#cacheTtlMillis);\n    }\n\n    return records.then(rs => {\n      const r = this.#pickRandomRecord(rs);\n      return `${r.name}:${r.port}`;\n    });\n  }\n\n  /**\n   * Among a set of records, pick one at random.\n   *\n   * This assumes that the set is not empty.\n   *\n   * Since this contract only ever returns a single record, the best it can do\n   * is to pick weighted-randomly among the highest-priority records. In order\n   * to be smarter than that, the caller would have to be able to make decisions\n   * on the whole set of records.\n   */\n  #pickRandomRecord(allRecords: SrvRecord[]): SrvRecord {\n    // Lowest priority number means highest priority\n    const lowestPriority = allRecords.reduce(\n      (acc, r) => Math.min(acc, r.priority),\n      Number.MAX_SAFE_INTEGER,\n    );\n    const records = allRecords.filter(r => r.priority === lowestPriority);\n\n    const totalWeight = records.reduce((acc, r) => acc + r.weight, 0);\n    const targetWeight = Math.random() * totalWeight;\n\n    // Just as a fallback, we expect the loop below to always find a result\n    let result = records[0];\n    let currentWeight = 0;\n\n    for (const record of records) {\n      currentWeight += record.weight;\n      if (targetWeight <= currentWeight) {\n        result = record;\n        break;\n      }\n    }\n\n    return result;\n  }\n}\n"],"names":["resolveSrv","InputError","NotFoundError","ForwardedError"],"mappings":"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"}